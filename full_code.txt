

===== C:\Users\USER\Projects\robomine-capital\next.config.ts =====

// next.config.ts
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
    async rewrites() {
        return [
            {
                source: '/api/v1/:path*',
                destination: 'https://robomine.ru/api/v1/:path*',
            },
        ];
    },
};

export default nextConfig;


===== C:\Users\USER\Projects\robomine-capital\src\app\deposit\page.tsx =====

'use client';

// @/app/deposit/page.tsx
import { DepositForm } from '@/features/deposit';
import { BackButton } from '@/shared/ui';
import { Header } from '@/widgets/header';
import styles from './Deposit.module.scss';

export default function DepositPage() {
    return (
        <div className={styles.depositPage}>
            <BackButton />
            <h1 className={styles.title}>Пополнение баланса</h1>

            <Header />

            <div className={styles.formContainer}>
                <span>Сумма пополнения</span>
                <DepositForm />
            </div>
        </div>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\app\error.tsx =====

'use client';

import { useEffect } from 'react';
import { Button } from '@/shared/ui/button';

export default function Error({ error, reset }: { error: Error; reset: () => void }) {
    useEffect(() => {
        console.error(error);
    }, [error]);

    return (
        <div>
            <h1>Ошибка</h1>
            <p>Произошла ошибка при загрузке страницы.</p>
            <Button onClick={() => reset()} className="" label="Попробовать снова" />
        </div>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\app\layout.tsx =====

// app/layout.tsx
import type { Metadata } from 'next';
import { Lato } from 'next/font/google';
import '@/shared/styles/global.scss';
import { AppProviders } from '../shared/lib/providers';
import styles from './layout.module.scss';
import { MaintenanceScreen } from '@/shared/ui/maintenance-screen/MaintenanceScreen';

// Подключаем шрифт Lato
const latoSans = Lato({
    weight: ['100', '300', '400', '700', '900'],
    variable: '--font-lato',
    subsets: ['latin', 'latin-ext'],
    display: 'swap',
});

export const metadata: Metadata = {
    title: {
        default: 'RoboMine Сapital',
        template: '%s | RoboMine Сapital',
    },
    description: 'Зарабатывай на майнинге криптовалюты',
    metadataBase: new URL(process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'),
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {

    const isMaintenance = process.env.NEXT_PUBLIC_MAINTENANCE_MODE === 'true';

    if (isMaintenance) {
        return (
            <html lang="ru" suppressHydrationWarning>
                <head>
                    <script src="https://telegram.org/js/telegram-web-app.js" async></script>
                </head>
                <body className={`${styles.layout} ${latoSans.variable}`}>
                    <MaintenanceScreen />
                </body>
            </html>
        );
    }
    
    return (
        <html lang="ru" suppressHydrationWarning>
            <head>
                <script src="https://telegram.org/js/telegram-web-app.js" async></script>
            </head>
            <body className={`${styles.layout} ${latoSans.variable} `}>
                <main className={styles.content}>
                    <AppProviders>{children}</AppProviders>
                </main>
            </body>
        </html>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\app\loading.tsx =====

// @/app/loading.tsx
import styles from './Home.module.scss';

export default function Loading() {
    return <div className={styles.loading}></div>;
}


===== C:\Users\USER\Projects\robomine-capital\src\app\not-found.tsx =====

// @/app/not-found.tsx

export default function NotFound() {
    return (
        <div>
            <h1 className="not-found__title">404</h1>
            <p className="not-found__description">Страница не найдена</p>
        </div>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\app\page.tsx =====

'use client';

// app/page.tsx
import { useMachines } from '@/shared/lib/contexts';
import { ActionButtons } from '@/widgets/action-buttons';
import { BuyMachineLink } from '@/widgets/by-machine-link';
import { Header } from '@/widgets/header';
import { MachineList } from '@/widgets/machine-list';
import styles from './Home.module.scss';

export default function HomePage() {
    const { machines, loading, error } = useMachines();

    if (loading) {
        return null;
    }

    if (error) {
        return <div className={styles.homePage}>Ошибка загрузки данных.</div>;
    }

    const hasPurchasedMachines = machines.some(
        (machine) => (machine.state_car?.status ?? 'not_purchased') !== 'not_purchased'
    );

    return (
        <div className={styles.homePage}>
            <Header />
            <ActionButtons />

            {hasPurchasedMachines ? (
                <div className={styles.machinesContainer}>
                    <MachineList filterType="purchased" showBuyMoreCard={true} />
                </div>
            ) : (
                <BuyMachineLink />
            )}
        </div>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\app\referral\page.tsx =====

'use client';

// src/app/referral/page.tsx
import { useReferrals } from '@/shared/lib/contexts';
import { useUser } from '@/shared/lib/contexts/UserContext';
import { BackButton, Button } from '@/shared/ui';
import { ReferralBalance } from '@/widgets/referral-balance';
import { ReferralLink } from '@/widgets/referral-link';
import { ReferralList } from '@/widgets/referral-list';
import styles from './Referral.module.scss';

export default function ReferralPage() {
    const { user } = useUser();
    const { referralsData } = useReferrals();

    const handleInvite = () => {
        if (!user?.telegram_id) {
            return;
        }

        const referralLink = `https://t.me/RoboMine_CapitalBot?start=${user.telegram_id}`;
        const message = `Присоединяйся к RoboMine Capital и начни зарабатывать!`;
        const telegramShareUrl = `https://t.me/share/url?url=${encodeURIComponent(referralLink)}&text=${encodeURIComponent(message)}`;
        window.open(telegramShareUrl, '_blank');
    };

    return (
        <div className={styles.referralPage}>
            <BackButton />
            <h1 className={styles.title}>Рефераллы</h1>

            <p className={styles.referralText}>Ваши рефералы уже заработали для вас:</p>
            <ReferralBalance />

            <p className={styles.referralText}>Ваша реферальная ссылка:</p>
            <ReferralLink telegramId={user?.telegram_id} />
            <Button className={styles.button} onClick={handleInvite}>
                Пригласить
            </Button>
            {referralsData && <ReferralList referrals={referralsData.referrals} />}
        </div>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\app\shop\page.tsx =====

// @/app/shop/page.tsx
import { BackButton } from '@/shared/ui';
import { MachineList } from '@/widgets/machine-list';
import styles from './Shop.module.scss';

export default function ShopPage() {
    return (
        <div className={styles.shopPage}>
            <BackButton />
            <h1 className={styles.title}>Майнинг машины</h1>
            <MachineList filterType="not_purchased" showBuyMoreCard={false} />
        </div>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\app\withdraw\page.tsx =====

'use client';

// @/app/withdraw/page.tsx
import { WithdrawForm } from '@/features/withdraw';
import { BackButton } from '@/shared/ui';
import { Header } from '@/widgets/header';
import styles from './Withdraw.module.scss';

export default function WithdrawPage() {
    return (
        <div className={styles.withdrawPage}>
            <BackButton />
            <h1 className={styles.title}>Вывод средств</h1>

            <Header />

            <div className={styles.formContainer}>
                <span>Сумма вывода</span>
                <WithdrawForm />
            </div>
        </div>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\entities\deposit\api\deposit.api.ts =====

// entities/deposit/api/deposit.api.ts
import { api } from '@/shared/api';
import { DepositDto } from '../model/types';

/**
 * Создать инвойс для пополнения баланса
 * @param asset - Криптовалюта (например, "TON", "BTC")
 * @param amount - Сумма пополнения
 * @returns Данные о созданном депозите
 */
export const createDepositInvoice = async (asset: string, amount: string): Promise<DepositDto> => {
    const response = await api.post<DepositDto>('/deposits/create', {
        asset,
        amount,
    });

    return response.data;
};

/**
 * Получить историю депозитов текущего пользователя
 * @returns Список депозитов
 */
export const getDepositHistory = async (): Promise<DepositDto[]> => {
    const response = await api.get<DepositDto[]>('/deposits/history');

    return response.data;
};


===== C:\Users\USER\Projects\robomine-capital\src\entities\deposit\api\index.ts =====

export {} from './';
export { createDepositInvoice, getDepositHistory } from './deposit.api';


===== C:\Users\USER\Projects\robomine-capital\src\entities\deposit\index.ts =====

export * from './api';
export * from './model';
export * from './ui';


===== C:\Users\USER\Projects\robomine-capital\src\entities\deposit\model\index.ts =====

export * from './';
export type { DepositDto } from './types';


===== C:\Users\USER\Projects\robomine-capital\src\entities\deposit\model\types.ts =====

// entities/deposit/model/types.ts
export interface DepositDto {
    id: number;
    telegram_id: number;
    invoice_id: number;
    hash: string;
    amount: number;
    status: 'pending' | 'completed' | 'failed';
    created_at: string; // ISO string
    updated_at: string; // ISO string
}


===== C:\Users\USER\Projects\robomine-capital\src\entities\deposit\ui\index.ts =====

export {} from '.';


===== C:\Users\USER\Projects\robomine-capital\src\entities\machine\api\index.ts =====

export {
    activateMachine,
    getAllMachines,
    getMachineById,
    purchaseMachine,
    transitionMachine,
} from './machine.api';


===== C:\Users\USER\Projects\robomine-capital\src\entities\machine\api\machine.api.ts =====

// entities/machine/api/machine.api.ts
import { api } from '@/shared/api';
import {
    ActivateMachineDto,
    MachineAttributes,
    MachineWithState,
    PurchaseMachineDto,
    TransitionMachineDto,
} from '../model/types';

/**
 * Получить список всех машин с состоянием для текущего пользователя
 */
export const getAllMachines = async (): Promise<MachineWithState[]> => {
    const response = await api.get<MachineWithState[]>('/cars/');
    return response.data;
};

/**
 * Получить конкретную машину по ID
 */
export const getMachineById = async (id: number): Promise<MachineAttributes> => {
    const response = await api.get<MachineAttributes>(`/cars/${id}`);
    return response.data;
};

/**
 * Купить машину
 */
export const purchaseMachine = async (data: PurchaseMachineDto): Promise<boolean> => {
    const response = await api.post<boolean>('/cars/purchase', data);
    return response.data;
};

/**
 * Активировать купленную машину
 */
export const activateMachine = async (data: ActivateMachineDto): Promise<{ message: string }> => {
    const response = await api.put<{ message: string }>('/cars/activate', data);
    return response.data;
};

/**
 * Перевести машину в следующее состояние (например, из waiting_for_reward в awaiting)
 */
export const transitionMachine = async (
    data: TransitionMachineDto
): Promise<{ message: string }> => {
    const response = await api.put<{ message: string }>('/cars/take', data);
    return response.data;
};


===== C:\Users\USER\Projects\robomine-capital\src\entities\machine\index.ts =====

export * from './api';
export * from './model';
export * from './ui';


===== C:\Users\USER\Projects\robomine-capital\src\entities\machine\lib\status.ts =====

// entities/machine/lib/status.ts
import { MachineToUserAttributes } from '../model/types';

export const getMachineStatus = (status: MachineToUserAttributes['status']) => {
    switch (status) {
        case 'not_purchased':
            return {
                isPurchased: false,
                displayStatus: 'not_purchased' as const,
            };
        case 'awaiting':
            return {
                isPurchased: true,
                displayStatus: 'awaiting' as const,
            };
        case 'in_progress':
            return {
                isPurchased: true,
                displayStatus: 'in_progress' as const,
            };
        case 'waiting_for_reward':
            return {
                isPurchased: true,
                displayStatus: 'waiting_for_reward' as const,
            };
        case 'completed':
            return {
                isPurchased: true,
                displayStatus: 'completed' as const,
            };
        default:
            return {
                isPurchased: false,
                displayStatus: 'not_purchased' as const,
            };
    }
};

export const getMachineActionText = (
    isPurchased: boolean,
    status: MachineToUserAttributes['status'],
    isProcessing: boolean,
    isCollectingReward: boolean
) => {
    if (!isPurchased) return 'Купить';

    switch (status) {
        case 'awaiting':
            return 'Активировать';
        case 'in_progress':
            return isProcessing ? 'Активация...' : 'Активировано';
        case 'waiting_for_reward':
            return isCollectingReward ? 'Получение...' : 'Забрать';
        case 'completed':
            return 'Купить';
        default:
            return 'Куплена';
    }
};


===== C:\Users\USER\Projects\robomine-capital\src\entities\machine\model\index.ts =====

export type {
    ActivateMachineDto,
    CreateMachineDto,
    MachineAttributes,
    MachineCreationAttributes,
    MachineToUserAttributes,
    MachineWithState,
    PurchaseMachineDto,
    TransitionMachineDto,
} from './types';


===== C:\Users\USER\Projects\robomine-capital\src\entities\machine\model\types.ts =====

// entities/machine/model/types.ts

// --- DTO для создания машины ---
export interface CreateMachineDto {
    name: string;
    price: number;
    status: boolean;
    lifespan: number; // срок службы в днях
    daily_replenishment: number; // ежедневное пополнение баланса
    daily_replenishment_tokens: number; // ежедневные токены
    profit_percentage: number; // процент прибыли
    image?: string; // URL изображения
}

// --- Атрибуты модели машины (из БД) ---
export interface MachineAttributes {
    id: number;
    name: string;
    price: number;
    status: boolean;
    lifespan: number;
    daily_replenishment: number;
    daily_replenishment_tokens: number;
    profit_percentage: number;
    image: string;
    created_at: Date;
    updated_at: Date;
}

type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;

// --- Атрибуты для создания (без id и timestamps) ---
export type MachineCreationAttributes = Optional<
    MachineAttributes,
    | 'id'
    | 'daily_replenishment_tokens'
    | 'profit_percentage'
    | 'image'
    | 'created_at'
    | 'updated_at'
>;

// --- DTO для связи машина-пользователь ---
export interface MachineToUserAttributes {
    id: number;
    telegram_id: number;
    machine_id: number;
    remaining_uses: number;
    status: 'not_purchased' | 'awaiting' | 'in_progress' | 'waiting_for_reward' | 'completed';
    last_updated: number;
    created_at: Date;
    updated_at: Date;
}

export interface PurchaseMachineDto {
    car_id: number;
}

export interface ActivateMachineDto {
    car_id: number;
}

export interface TransitionMachineDto {
    car_to_user_id: number;
}

// --- Тип для ответа getAllMachines ---
export interface MachineWithState {
    car: MachineAttributes;
    state_car: {
        id: number | null;
        telegram_id: number;
        car_id: number | null;
        remaining_uses: number;
        status: MachineToUserAttributes['status'];
        last_updated: number;
    };
}


===== C:\Users\USER\Projects\robomine-capital\src\entities\machine\ui\index.ts =====

export {} from '.';


===== C:\Users\USER\Projects\robomine-capital\src\entities\user\api\index.ts =====

export {
    banUser,
    checkUserExists,
    createUser,
    getAllUsers,
    getMe,
    getUserReferrals,
    replenishUserBalance,
    unbanUser,
} from './user.api';


===== C:\Users\USER\Projects\robomine-capital\src\entities\user\api\user.api.ts =====

// entities/user/api/user.api.ts
import { api } from '@/shared/api';
import {
    BanUserDto,
    CreateUserDto,
    ReplenishDto,
    UserAttributes,
    UserReferralData,
} from '../model/types';

/**
 * Проверить, существует ли пользователь по telegram_id
 */
// entities/user/api/user.api.ts
/**
 * Проверить, существует ли пользователь по telegram_id
 */
export const checkUserExists = async (telegram_id: number): Promise<boolean> => {
    try {
        const response = await api.get<boolean>(`/users/check/${telegram_id}`);
        return response.data;
    } catch (error) {
        // Проверяем, является ли ошибка Axios ошибкой с response
        if (error && typeof error === 'object' && 'response' in error) {
            const axiosError = error as { response?: { status: number } };
            if (axiosError.response?.status === 404) {
                return false; // Пользователь не найден
            }
        }
        // Для других ошибок логируем и пробрасываем
        console.error('Error checking user existence:', error);
        throw error;
    }
};

/**
 * Создать нового пользователя
 */
export const createUser = async (userData: CreateUserDto): Promise<UserAttributes> => {
    const response = await api.post<UserAttributes>('/users/create', userData);
    return response.data;
};

/**
 * Получить данные текущего пользователя
 */
export const getMe = async (): Promise<UserAttributes> => {
    const response = await api.get<UserAttributes>('/users/getMe');
    return response.data;
};

/**
 * Получить рефералов текущего пользователя
 */
export const getUserReferrals = async (): Promise<UserReferralData> => {
    const response = await api.get<UserReferralData>('/users/get-referrals');
    return response.data;
};

/**
 * Пополнить баланс пользователя (админская функция или для тестов)
 * ВАЖНО: Этот endpoint требует авторизации админа на бэкенде
 */
export const replenishUserBalance = async (data: ReplenishDto): Promise<UserAttributes> => {
    const response = await api.put<UserAttributes>('/users/replenish', data);
    return response.data;
};

/**
 * Забанить пользователя (админская функция)
 * ВАЖНО: Этот endpoint требует авторизации админа на бэкенде
 */
export const banUser = async (user_id: number, data: BanUserDto): Promise<UserAttributes> => {
    const response = await api.put<UserAttributes>(`/users/ban/${user_id}`, data);
    return response.data;
};

/**
 * Разбанить пользователя (админская функция)
 * ВАЖНО: Этот endpoint требует авторизации админа на бэкенде
 */
export const unbanUser = async (user_id: number): Promise<UserAttributes> => {
    const response = await api.put<UserAttributes>(`/users/unban/${user_id}`);
    return response.data;
};

/**
 * Получить список всех пользователей (админская функция)
 * ВАЖНО: Этот endpoint требует авторизации админа на бэкенде
 */
export const getAllUsers = async (): Promise<UserAttributes[]> => {
    const response = await api.get<UserAttributes[]>('/users/admin/get-all-users');
    return response.data;
};


===== C:\Users\USER\Projects\robomine-capital\src\entities\user\index.ts =====

export * from './api';
export * from './model';
export * from './ui';


===== C:\Users\USER\Projects\robomine-capital\src\entities\user\model\index.ts =====

export type {
    BanUserDto,
    CreateUserDto,
    ReplenishDto,
    UserAttributes,
    UserCreationAttributes,
    UserReferralData,
} from './types';

export { UserProvider, useUser } from '../../../shared/lib/contexts/UserContext';
export { useUserInit } from './useUserInit';
export {} from './';


===== C:\Users\USER\Projects\robomine-capital\src\entities\user\model\types.ts =====

// entities/user/model/types.ts
type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;

// --- Атрибуты модели пользователя (из БД) ---
export interface UserAttributes {
    id: number;
    telegram_id: number;
    ref_id: number;
    role: string;
    username: string;
    balance: number;
    tokens: number;
    ref_balance: number;
    referrer_profit: number;
    blago_status: boolean;
    level: number;
    subscription: boolean;
    is_banned: boolean;
    ban_until: Date;
    created_at: Date;
    updated_at: Date;
}

// --- Атрибуты для создания (без id и timestamps) ---
export type UserCreationAttributes = Optional<
    UserAttributes,
    | 'id'
    | 'role'
    | 'username'
    | 'balance'
    | 'tokens'
    | 'ref_balance'
    | 'referrer_profit'
    | 'blago_status'
    | 'level'
    | 'subscription'
    | 'is_banned'
    | 'ban_until'
    | 'created_at'
    | 'updated_at'
>;

// --- DTO для создания пользователя ---
export interface CreateUserDto {
    telegram_id: number;
    username: string;
    ref_id?: number;
    tokens?: number;
}

// --- DTO для пополнения баланса ---
export interface ReplenishDto {
    telegram_id: number;
    amount: number;
}

// --- DTO для бана/разбана ---
export interface BanUserDto {
    date?: string; // Формат: "HH:mm DD.MM.YYYY"
}

// --- Тип для ответа getUserReferrals ---
export interface UserReferralData {
    referrals: Omit<UserAttributes, 'ban_until' | 'created_at' | 'updated_at'>[];
    referralCount: number;
}


===== C:\Users\USER\Projects\robomine-capital\src\entities\user\model\useUserInit.ts =====

'use client';

// entities/user/model/useUserInit.ts
import { useEffect, useState } from 'react';
import { AxiosError } from 'axios';
import { checkUserExists, createUser, getMe } from '@/entities/user/api/user.api';
import { CreateUserDto, UserAttributes } from '@/entities/user/model/types';
import { useTelegramWebApp } from '@/shared/lib/hooks/useTelegramWebApp';

// Расширяем интерфейс Window для глобальной переменной
declare global {
    interface Window {
        telegramUser?: UserAttributes;
    }
}

export const useUserInit = () => {
    const [user, setUser] = useState<UserAttributes | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const { tgUser, isLoading: isTgLoading } = useTelegramWebApp();

    useEffect(() => {
        console.log(
            'useUserInit useEffect triggered. tgUser:',
            tgUser,
            'isTgLoading:',
            isTgLoading
        );

        const initializeUser = async () => {
            try {
                if (isTgLoading) {
                    console.log('Telegram WebApp data is still loading (isTgLoading=true)');
                    return;
                }
                if (!tgUser?.id) {
                    console.warn('tgUser.id NOT found. Cannot initialize user.');
                    setError('Не удалось получить данные пользователя из Telegram');
                    setIsLoading(false);
                    return;
                }

                setIsLoading(true);
                setError(null);

                // Проверяем существование пользователя
                const exists = await checkUserExists(tgUser.id);

                if (!exists) {
                    // Создаем нового пользователя
                    const userData: CreateUserDto = {
                        telegram_id: tgUser.id,
                        username: tgUser.username || `user_${tgUser.id}`,
                    };
                    try {
                        const newUser = await createUser(userData);
                        setUser(newUser);
                        // Сохраняем данные пользователя в глобальную переменную (если нужно)
                        if (typeof window !== 'undefined') {
                            window.telegramUser = newUser;
                        }
                    } catch (createError: unknown) {
                        // Обрабатываем 409 Conflict - пользователь уже существует
                        if (
                            createError instanceof AxiosError &&
                            createError.response?.status === 409
                        ) {
                            const userData = await getMe();
                            setUser(userData);
                            // Сохраняем данные пользователя в глобальную переменную (если нужно)
                            if (typeof window !== 'undefined') {
                                window.telegramUser = userData;
                            }
                        } else {
                            // Другая ошибка - пробрасываем её дальше
                            throw createError;
                        }
                    }
                } else {
                    // Пользователь существует, получаем данные
                    const userData = await getMe();
                    setUser(userData);
                    // Сохраняем данные пользователя в глобальную переменную (если нужно)
                    if (typeof window !== 'undefined') {
                        window.telegramUser = userData;
                    }
                }
            } catch (err: unknown) {
                console.error('Ошибка инициализации пользователя:', err);
                if (err instanceof Error) {
                    setError(`Ошибка инициализации: ${err.message}`);
                } else {
                    setError('Неизвестная ошибка инициализации');
                }
            } finally {
                setIsLoading(false);
            }
        };

        initializeUser();
    }, [tgUser, isTgLoading]);

    return { user, isLoading, error };
};


===== C:\Users\USER\Projects\robomine-capital\src\entities\user\ui\index.ts =====

export {} from './';


===== C:\Users\USER\Projects\robomine-capital\src\entities\withdrawal\api\index.ts =====

export {
    confirmWithdrawal,
    getPendingWithdrawals,
    getWithdrawalRestriction,
    rejectWithdrawal,
    transfer,
} from './withdrawal.api';


===== C:\Users\USER\Projects\robomine-capital\src\entities\withdrawal\api\withdrawal.api.ts =====

// entities/withdrawal/api/withdrawal.api.ts
import { api } from '@/shared/api';
import {
    CreateWithdrawalDto,
    PendingWithdrawal,
    TransferResult,
    WithdrawalRestriction,
} from '../model/types';

/**
 * Инициировать вывод средств
 */
export const transfer = async (
    data: Omit<CreateWithdrawalDto, 'spend_id'>
): Promise<TransferResult> => {
    const response = await api.post<TransferResult>('/withdrawal/transfer', data);
    return response.data;
};

/**
 * Получить ограничения на вывод средств
 */
export const getWithdrawalRestriction = async (): Promise<WithdrawalRestriction> => {
    const response = await api.get<WithdrawalRestriction>('/withdrawal/restriction');
    return response.data;
};

/**
 * Получить список ожидающих подтверждения выводов (админская функция)
 * ВАЖНО: Этот endpoint требует авторизации админа на бэкенде
 */
export const getPendingWithdrawals = async (): Promise<PendingWithdrawal[]> => {
    const response = await api.get<PendingWithdrawal[]>('/withdrawal/admin/pending');
    return response.data;
};

/**
 * Подтвердить вывод средств (админская функция)
 * ВАЖНО: Этот endpoint требует авторизации админа на бэкенде
 */
export const confirmWithdrawal = async (id: number): Promise<TransferResult> => {
    const response = await api.post<TransferResult>(`/withdrawal/admin/confirm/${id}`);
    return response.data;
};

/**
 * Отклонить вывод средств (админская функция)
 * ВАЖНО: Этот endpoint требует авторизации админа на бэкенде
 */
export const rejectWithdrawal = async (id: number): Promise<TransferResult> => {
    const response = await api.post<TransferResult>(`/withdrawal/admin/reject/${id}`);
    return response.data;
};


===== C:\Users\USER\Projects\robomine-capital\src\entities\withdrawal\index.ts =====

export * from './api';
export * from './model';
export * from './ui';


===== C:\Users\USER\Projects\robomine-capital\src\entities\withdrawal\model\index.ts =====

export type {
    CreateWithdrawalDto,
    PendingWithdrawal,
    ProcessWithdrawalDto,
    TransferResult,
    WithdrawalAttributes,
    WithdrawalCreationAttributes,
    WithdrawalRestriction,
} from './types';


===== C:\Users\USER\Projects\robomine-capital\src\entities\withdrawal\model\types.ts =====

// entities/withdrawal/model/types.ts
type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;

// --- Атрибуты модели вывода (из БД) ---
export interface WithdrawalAttributes {
    id: number;
    telegram_id: number;
    hash: string;
    amount: number;
    status: 'pending' | 'pending_confirmation' | 'completed' | 'rejected';
    created_at: Date;
    updated_at: Date;
}

// --- Атрибуты для создания (без id и timestamps) ---
export type WithdrawalCreationAttributes = Optional<
    WithdrawalAttributes,
    'id' | 'created_at' | 'updated_at'
>;

// --- DTO для создания вывода ---
export interface CreateWithdrawalDto {
    amount: string; // Сумма как строка, как в бэкенде
    spend_id?: string; // Опционально, генерируется бэкендом если не передан
    comment?: string;
    disable_send_notification?: boolean;
}

// --- DTO для подтверждения/отклонения вывода (админ) ---
export interface ProcessWithdrawalDto {
    id: number;
}

// --- Тип для ограничений на вывод ---
export interface WithdrawalRestriction {
    message: string;
    availableDays?: string[]; // Только если есть ограничения по времени
}

// --- Тип для списка ожидающих выводов (админ) ---
export type PendingWithdrawal = WithdrawalAttributes;

// --- Тип для ответа transfer (основная операция) ---
export type TransferResult = WithdrawalAttributes;


===== C:\Users\USER\Projects\robomine-capital\src\entities\withdrawal\ui\index.ts =====

export {} from '.';


===== C:\Users\USER\Projects\robomine-capital\src\features\claim-animation\index.ts =====

export * from './ui';


===== C:\Users\USER\Projects\robomine-capital\src\features\claim-animation\ui\ClaimAnimation.tsx =====

'use client';

// src/features/claim-animation/ui/ClaimAnimation.tsx
import { useEffect, useState } from 'react';
import clsx from 'clsx';
import { Coin } from '@/shared/assets/icons';
import styles from './ClaimAnimation.module.scss';

export const ClaimAnimation = () => {
    const [shouldAnimateCoins, setShouldAnimateCoins] = useState(false);

    useEffect(() => {
        // Небольшая задержка для уверенности, что DOM готов для анимации
        const timer = setTimeout(() => {
            setShouldAnimateCoins(true);
        }, 10);

        return () => clearTimeout(timer);
    }, []);

    return (
        <div className={styles.claimAnimation}>
            <Coin className={clsx(styles.coin, styles.coinCentral)} width={50} height={50} />

            <div
                className={clsx(styles.coin, styles.coinTopLeft, {
                    [styles.animate]: shouldAnimateCoins,
                })}
            >
                <Coin width={50} height={50} />
            </div>
            <div
                className={clsx(styles.coin, styles.coinTopRight, {
                    [styles.animate]: shouldAnimateCoins,
                })}
            >
                <Coin width={50} height={50} />
            </div>
            <div
                className={clsx(styles.coin, styles.coinBottomRight, {
                    [styles.animate]: shouldAnimateCoins,
                })}
            >
                <Coin width={50} height={50} />
            </div>
            <div
                className={clsx(styles.coin, styles.coinBottomLeft, {
                    [styles.animate]: shouldAnimateCoins,
                })}
            >
                <Coin width={50} height={50} />
            </div>
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\features\claim-animation\ui\index.ts =====

export { ClaimAnimation } from './ClaimAnimation';


===== C:\Users\USER\Projects\robomine-capital\src\features\currency-converter\index.ts =====

export * from './model';


===== C:\Users\USER\Projects\robomine-capital\src\features\currency-converter\model\converter.ts =====

// src/features/currency-converter/model/converter.ts
import { ConvertCurrencyParams } from './types';

export const convertCurrency = ({ amount, from, to, rates }: ConvertCurrencyParams): number => {
    // 1. Если конвертируем валюту в саму себя, возвращаем исходную сумму
    if (from === to) {
        return amount;
    }

    // 2. Проверяем, существуют ли курсы для обеих валют
    //    и передан ли сам объект rates
    if (!rates || rates[from] === undefined || rates[to] === undefined) {
        console.warn(`Курс для валюты ${from} или ${to} не найден в переданных rates.`, {
            rates,
            from,
            to,
        });
        // Можно бросить ошибку или вернуть 0
        return 0;
        // throw new Error(`Курс для валюты ${from} или ${to} не найден.`);
    }

    // 3. --- Логика конвертации ---
    // Предположение: `rates` содержит курсы относительно базовой валюты RUB.
    // `rates['USDT']` означает, сколько RUB эквивалентно 1 единице USDT.
    // Например: rates = { RUB: 1, USDT: 0.011 }
    // Это значит: 1 RUB = 0.011 USDT, или 1 USDT = 1 / 0.011 ≈ 90.91 RUB

    // Чтобы конвертировать `amount` из `from` в `to`:
    // a. Сначала находим, сколько базовой валюты (RUB) эквивалентно `amount` валюты `from`.
    //    amountInRub = amount * (1 / rates[from])
    //    (Потому что rates[from] говорит, сколько RUB в 1 единице валюты from)
    //    Пример: amount = 10 USDT, rates['USDT'] = 0.011
    //    amountInRub = 10 * (1 / 0.011) = 10 * 90.91 ≈ 909.09 RUB

    // b. Затем конвертируем эту сумму из базовой валюты (RUB) в целевую валюту `to`.
    //    result = amountInRub * rates[to]
    //    (Потому что rates[to] говорит, сколько RUB эквивалентно 1 единице валюты to)
    //    Пример: amountInRub = 909.09 RUB, rates['RUB'] = 1
    //    result = 909.09 * 1 = 909.09 RUB (если to = 'RUB')
    //    Если бы to = 'EUR' и rates['EUR'] = 0.0095 (1 RUB = 0.0095 EUR)
    //    result = 909.09 * 0.0095 ≈ 8.64 EUR

    // Объединяя шаги a и b:
    // result = (amount * (1 / rates[from])) * rates[to]
    // result = (amount * rates[to]) / rates[from]

    const result = (amount * rates[to]) / rates[from];

    // 4. Округляем результат до разумного количества знаков после запятой.
    // Для финансовых расчетов часто достаточно 2-8 знаков.
    // Предположим, 6 знаков после запятой подходит для криптовалют.
    // Math.round(result * 1_000_000) / 1_000_000 эквивалентно округлению до 6 знаков.
    // Альтернатива: parseFloat(result.toFixed(6))
    return Math.round(result * 1_000_000) / 1_000_000;
    // Или, если хотите всегда 3 знака (как в Balance):
    // return parseFloat(result.toFixed(3));
};


===== C:\Users\USER\Projects\robomine-capital\src\features\currency-converter\model\index.ts =====

export { convertCurrency } from './converter';
export { useCurrencyConverter } from './useCurrencyConverter';
export {} from './';


===== C:\Users\USER\Projects\robomine-capital\src\features\currency-converter\model\types.ts =====

// @/features/currency-converter/model/types.ts
export interface CurrencyRates {
    [key: string]: number;
}

export interface ConvertCurrencyParams {
    amount: number;
    from: string;
    to: string;
    rates: CurrencyRates;
}


===== C:\Users\USER\Projects\robomine-capital\src\features\currency-converter\model\useCurrencyConverter.tsx =====

'use client';

// src/features/currency-converter/model/useCurrencyConverter.tsx
import { useEffect, useState } from 'react';
import { CurrencyRates } from './types';

const CACHE_KEY = 'currencyConverterRates';
// Установите желаемое время кэширования (например, 15 минут = 15 * 60 * 1000 миллисекунд)
const CACHE_DURATION_MS = 15 * 60 * 1000;

export const useCurrencyConverter = () => {
    const [rates, setRates] = useState<CurrencyRates | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        let isMounted = true;

        const fetchRates = async () => {
            setLoading(true);
            setError(null);

            try {
                // 1. Попытка получить данные из localStorage
                if (typeof window !== 'undefined') {
                    const cachedDataString = localStorage.getItem(CACHE_KEY);
                    if (cachedDataString) {
                        const cachedData = JSON.parse(cachedDataString);
                        const now = Date.now();
                        // Проверяем, не истекло ли время кэша
                        if (now - cachedData.timestamp < CACHE_DURATION_MS) {
                            console.log('Использованы кэшированные курсы валют');
                            if (isMounted) {
                                setRates(cachedData.rates);
                                setLoading(false);
                            }
                            return; // Используем кэш, запрос не нужен
                        } else {
                            console.log('Кэш курсов валют устарел');
                        }
                    }
                }

                // 2. Если кэша нет или он устарел, делаем запрос к API
                console.log('Запрос курсов валют к API...');
                const response = await fetch(
                    'https://api.coingecko.com/api/v3/simple/price?ids=tether&vs_currencies=rub'
                );

                if (!response.ok) {
                    throw new Error(`Ошибка сети: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                const usdtToRubRate = data?.tether?.rub;

                if (typeof usdtToRubRate === 'number' && usdtToRubRate > 0) {
                    const fetchedRates: CurrencyRates = {
                        RUB: 1,
                        USDT: 1 / usdtToRubRate,
                    };

                    // 3. Сохраняем полученные данные в localStorage с меткой времени
                    if (typeof window !== 'undefined') {
                        const cachePayload = {
                            rates: fetchedRates,
                            timestamp: Date.now(),
                        };
                        localStorage.setItem(CACHE_KEY, JSON.stringify(cachePayload));
                        console.log('Курсы валют сохранены в localStorage');
                    }

                    if (isMounted) {
                        setRates(fetchedRates);
                    }
                } else {
                    throw new Error('Не удалось получить корректный курс USDT/RUB.');
                }
            } catch (err) {
                console.error('Ошибка в useCurrencyConverter:', err);
                if (isMounted) {
                    if (err instanceof Error) {
                        setError(err.message || 'Ошибка загрузки курса USDT/RUB.');
                    } else {
                        setError('Неизвестная ошибка при загрузке курса.');
                    }
                }
            } finally {
                if (isMounted) {
                    setLoading(false);
                }
            }
        };

        fetchRates();

        return () => {
            isMounted = false;
        };
    }, []); // Пустой массив зависимостей - запуск только при монтировании

    return { rates, loading, error };
};


===== C:\Users\USER\Projects\robomine-capital\src\features\deposit\index.ts =====

export { DepositForm } from './ui/DepositForm';


===== C:\Users\USER\Projects\robomine-capital\src\features\deposit\model\types.ts =====



===== C:\Users\USER\Projects\robomine-capital\src\features\deposit\ui\DepositForm.tsx =====

'use client';

// @/features/deposit/ui/DepositForm.tsx
import { useEffect, useState } from 'react';
import { DepositDto, createDepositInvoice } from '@/entities/deposit';
import { convertCurrency, useCurrencyConverter } from '@/features/currency-converter';
import { Button, Input } from '@/shared/ui';
import styles from './DepositForm.module.scss';

export const DepositForm = () => {
    const [rubAmount, setRubAmount] = useState('');
    const [usdtAmount, setUsdtAmount] = useState('');
    const [lastChanged, setLastChanged] = useState<'RUB' | 'USDT'>('USDT');
    const { rates } = useCurrencyConverter();
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    // Эффект для конвертации USDT <-> RUB для отображения
    useEffect(() => {
        // Если поле очищено, очищаем и второе поле
        if (lastChanged === 'RUB') {
            if (!rubAmount) {
                // Если RUB очищен, очищаем USDT
                setUsdtAmount('');
            } else if (!isNaN(Number(rubAmount)) && rates) {
                // <-- Проверяем rates на null
                // Обновляем USDT на основе RUB
                const converted = convertCurrency({
                    amount: Number(rubAmount),
                    from: 'RUB',
                    to: 'USDT',
                    rates,
                });
                setUsdtAmount(converted.toString());
            }
        } else if (lastChanged === 'USDT') {
            if (!usdtAmount) {
                // Если USDT очищен, очищаем RUB
                setRubAmount('');
            } else if (!isNaN(Number(usdtAmount)) && rates) {
                // <-- Проверяем rates на null
                // Обновляем RUB на основе USDT
                const converted = convertCurrency({
                    amount: Number(usdtAmount),
                    from: 'USDT',
                    to: 'RUB',
                    rates,
                });
                setRubAmount(converted.toString());
            }
        }
    }, [rubAmount, usdtAmount, lastChanged, rates]);

    // Обработчики изменений полей ввода
    const isValidNumericInput = (value: string): boolean => {
        // Разрешает пустую строку, положительные числа и десятичные дроби
        // ^\d*\.?\d*$ - регулярное выражение:
        // ^ - начало строки
        // \d* - ноль или более цифр
        // \.? - опциональная точка
        // \d* - ноль или более цифр после точки
        // $ - конец строки
        return /^(\d+\.?\d*|\.\d+)?$/.test(value);
    };

    const handleRubChange = (value: string) => {
        // Убираем все символы, кроме цифр и точки
        const sanitizedValue = value.replace(/[^0-9.]/g, '');

        // Проверяем, является ли ввод допустимым числом
        if (isValidNumericInput(sanitizedValue)) {
            setRubAmount(sanitizedValue);
            setLastChanged('RUB');
            setError('');
        }
        // Если ввод недопустим, мы его игнорируем, не обновляя состояние
    };

    const handleUsdtChange = (value: string) => {
        // Убираем все символы, кроме цифр и точки
        const sanitizedValue = value.replace(/[^0-9.]/g, '');

        // Проверяем, является ли ввод допустимым числом
        if (isValidNumericInput(sanitizedValue)) {
            setUsdtAmount(sanitizedValue);
            setLastChanged('USDT');
            setError('');
        }
        // Если ввод недопустим, мы его игнорируем, не обновляя состояние
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault(); // Предотвращаем перезагрузку страницы

        // Основная проверка по полю USDT
        if (!usdtAmount || Number(usdtAmount) <= 0) {
            setError('Введите корректную сумму');
            return;
        }

        const assetToUse = 'USDT'; // Актив для оплаты
        const amountToUse = usdtAmount; // Сумма в USDT

        setIsLoading(true);
        setError('');

        try {
            console.log(`Создание инвойса для ${assetToUse}:`, amountToUse);
            // Вызываем API-функцию
            // Предполагаем, что бэкенд (DepositService) был изменен для возврата pay_url
            const invoiceData: DepositDto & { pay_url?: string } = await createDepositInvoice(
                assetToUse,
                amountToUse
            );

            console.log('Данные инвойса от бэкенда:', invoiceData);

            let payUrl: string | null = null;

            // Проверяем, есть ли pay_url в ответе
            if (invoiceData.pay_url) {
                payUrl = invoiceData.pay_url;
            } else if (invoiceData.invoice_id) {
                // Если нет, пробуем сформировать его (проверьте правильность формата!)
                // Формат может отличаться, уточните в документации CryptoBot
                payUrl = `https://t.me/CryptoBot?start=IV${invoiceData.invoice_id}`;
                console.warn(
                    'pay_url не найден в ответе бэкенда, формируем вручную. Проверьте формат.'
                );
            }

            if (payUrl) {
                console.log('Перенаправление на:', payUrl);
                window.location.href = payUrl;
            } else {
                setError('Ошибка получения ссылки на оплату. Обратитесь в поддержку.');
                console.error(
                    'Не удалось получить или сформировать pay_url из ответа:',
                    invoiceData
                );
            }
        } catch (err: unknown) {
            console.error('Ошибка при создании инвойса:', err);
            let errorMessage = 'Ошибка при попытке пополнения. Попробуйте позже.';

            if (err instanceof Error) {
                // Пытаемся извлечь сообщение об ошибке от бэкенда
                const axiosLikeError = err as { response?: { data?: { error?: string } } };
                if (axiosLikeError.response?.data?.error) {
                    errorMessage = `Ошибка: ${axiosLikeError.response.data.error}`;
                } else {
                    errorMessage = `Ошибка: ${err.message}`;
                }
            }
            // Если ошибка не является экземпляром Error, используем общее сообщение
            setError(errorMessage);
        }
    };

    // Проверяем, можно ли активировать кнопку
    const isButtonDisabled = !usdtAmount || Number(usdtAmount) <= 0;

    return (
        <form className={styles.depositForm} onSubmit={handleSubmit}>
            <Input
                type="tel"
                inputMode="decimal"
                pattern="[0-9]+([\.][0-9]+)?"
                variant="balance"
                placeholder="Введите сумму"
                value={rubAmount}
                onChange={(e) => handleRubChange(e.target.value)}
                currency="RUB"
            />

            <Input
                type="tel"
                inputMode="decimal"
                pattern="[0-9]+([\.][0-9]+)?"
                variant="balance"
                placeholder="Введите сумму"
                value={usdtAmount}
                onChange={(e) => handleUsdtChange(e.target.value)}
                currency="USDT"
                error={error}
            />

            <Button className={styles.button} type="submit" disabled={isButtonDisabled}>
                {isLoading ? 'Обработка...' : 'Пополнить'}
            </Button>
        </form>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\features\timer\model\useTimer.ts =====

// 'use client';

// import { useEffect, useState } from 'react';

// export const useTimer = (targetTimestamp: number | null) => {
//     const [timeLeft, setTimeLeft] = useState(() => {
//         if (!targetTimestamp) return 0;
//         return Math.max(0, targetTimestamp - Math.floor(Date.now() / 1000));
//     });

//     useEffect(() => {
//         const interval = setInterval(() => {
//             setTimeLeft((prev) => (prev > 0 ? prev - 1 : 0));
//         }, 1000);
//         return () => clearInterval(interval);
//     }, []);

//     return timeLeft;
// };


===== C:\Users\USER\Projects\robomine-capital\src\features\withdraw\index.ts =====

export { WithdrawForm } from './ui/WithdrawForm';


===== C:\Users\USER\Projects\robomine-capital\src\features\withdraw\model\hooks.ts =====



===== C:\Users\USER\Projects\robomine-capital\src\features\withdraw\model\types.ts =====



===== C:\Users\USER\Projects\robomine-capital\src\features\withdraw\ui\WithdrawForm.tsx =====

'use client';

// @/features/deposit/ui/WithdrawForm.tsx
import { useEffect, useState } from 'react';
import { TransferResult, transfer } from '@/entities/withdrawal';
import { convertCurrency, useCurrencyConverter } from '@/features/currency-converter';
import { Button, Input } from '@/shared/ui';
import styles from './WithdrawForm.module.scss';

export const WithdrawForm = () => {
    const [rubAmount, setRubAmount] = useState('');
    const [usdtAmount, setUsdtAmount] = useState('');
    const [lastChanged, setLastChanged] = useState<'RUB' | 'USDT'>('RUB');
    const { rates } = useCurrencyConverter();
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    // Эффект для конвертации USDT <-> RUB для отображения
    useEffect(() => {
        // Если поле очищено, очищаем и второе поле
        if (lastChanged === 'RUB') {
            if (!rubAmount) {
                // Если RUB очищен, очищаем USDT
                setUsdtAmount('');
            } else if (!isNaN(Number(rubAmount)) && rates) {
                // <-- Проверяем rates на null
                // Обновляем USDT на основе RUB
                const converted = convertCurrency({
                    amount: Number(rubAmount),
                    from: 'RUB',
                    to: 'USDT',
                    rates,
                });
                setUsdtAmount(converted.toString());
            }
        } else if (lastChanged === 'USDT') {
            if (!usdtAmount) {
                // Если USDT очищен, очищаем RUB
                setRubAmount('');
            } else if (!isNaN(Number(usdtAmount)) && rates) {
                // <-- Проверяем rates на null
                // Обновляем RUB на основе USDT
                const converted = convertCurrency({
                    amount: Number(usdtAmount),
                    from: 'USDT',
                    to: 'RUB',
                    rates,
                });
                setRubAmount(converted.toString());
            }
        }
    }, [rubAmount, usdtAmount, lastChanged, rates]);

    const isValidNumericInput = (value: string): boolean => {
        // Разрешает пустую строку, положительные числа и десятичные дроби
        // ^\d*\.?\d*$ - регулярное выражение:
        // ^ - начало строки
        // \d* - ноль или более цифр
        // \.? - опциональная точка
        // \d* - ноль или более цифр после точки
        // $ - конец строки
        return /^(\d+\.?\d*|\.\d+)?$/.test(value);
    };

    const handleRubChange = (value: string) => {
        // Убираем все символы, кроме цифр и точки
        const sanitizedValue = value.replace(/[^0-9.]/g, '');

        // Проверяем, является ли ввод допустимым числом
        if (isValidNumericInput(sanitizedValue)) {
            setRubAmount(sanitizedValue);
            setLastChanged('RUB');
            setError('');
        }
        // Если ввод недопустим, мы его игнорируем, не обновляя состояние
    };

    const handleUsdtChange = (value: string) => {
        // Убираем все символы, кроме цифр и точки
        const sanitizedValue = value.replace(/[^0-9.]/g, '');
        if (isValidNumericInput(sanitizedValue)) {
            setUsdtAmount(sanitizedValue);
            setLastChanged('USDT');
            setError('');
        }
        // Если ввод недопустим, мы его игнорируем, не обновляя состояние
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault(); // Предотвращаем перезагрузку страницы

        // Базовая валидация: проверяем, что сумма в USDT введена и положительна
        if (!usdtAmount || Number(usdtAmount) <= 0) {
            setError('Введите корректную сумму');
            return;
        }

        const amountToWithdraw = parseFloat(usdtAmount);

        setIsLoading(true);
        setError('');

        try {
            console.log(`Инициация вывода ${amountToWithdraw} USDT (эквивалент ~${rubAmount} RUB)`);

            const withdrawalResult: TransferResult = await transfer({ amount: usdtAmount });

            console.log('Результат вывода:', withdrawalResult);

            if (withdrawalResult.status === 'completed') {
                // Очищаем поля ввода
                setRubAmount('');
                setUsdtAmount('');
            } else {
                // Этот случай маловероятен, если auto_approve=true, но оставим на всякий
            }
        } catch (err: unknown) {
            console.error('Ошибка при выводе:', err);
            let errorMessage = 'Ошибка при попытке вывода. Попробуйте позже.';

            if (err instanceof Error) {
                // Пытаемся извлечь сообщение об ошибке от бэкенда
                const axiosLikeError = err as { response?: { data?: { error?: string } } };
                if (axiosLikeError.response?.data?.error) {
                    errorMessage = `Ошибка: ${axiosLikeError.response.data.error}`;
                } else {
                    errorMessage = `Ошибка: ${err.message}`;
                }
            }
            setError(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };

    // Проверяем, можно ли активировать кнопку
    // Разрешаем отправку, если введена корректная сумма в USDT
    const isButtonDisabled =
        !usdtAmount || isNaN(parseFloat(usdtAmount)) || parseFloat(usdtAmount) <= 0 || isLoading;

    return (
        <form className={styles.withdrawForm} onSubmit={handleSubmit}>
            <Input
                type="tel"
                inputMode="decimal"
                pattern="[0-9]+([\.][0-9]+)?"
                variant="balance"
                placeholder="Введите сумму"
                value={rubAmount}
                onChange={(e) => handleRubChange(e.target.value)}
                currency="RUB"
                // error={error} // Ошибки обычно привязаны к основному полю действия или отдельному сообщению
            />

            <Input
                type="tel"
                inputMode="decimal"
                pattern="[0-9]+([\.][0-9]+)?"
                variant="balance"
                placeholder="Введите сумму"
                value={usdtAmount}
                onChange={(e) => handleUsdtChange(e.target.value)}
                currency="USDT"
                error={error} // Отображаем ошибки на основном поле ввода (USDT)
            />

            <Button className={styles.button} type="submit" disabled={isButtonDisabled}>
                {isLoading ? 'Обработка...' : 'Вывести'}
            </Button>
        </form>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\api\axios.ts =====

// shared/api/axios.ts
import axios from 'axios';
import { API_URL } from '@/shared/config/env';

export const api = axios.create({
    baseURL: API_URL,
    withCredentials: true,
});

// Перехватчик запросов
api.interceptors.request.use(
    (config) => {
        if (typeof window !== 'undefined') {
            // Убеждаемся, что код выполняется на клиенте
            // Проверяем, локальная ли разработка
            const isLocalDev =
                window.location.hostname === 'localhost' ||
                window.location.hostname === '127.0.0.1';

            if (isLocalDev) {
                // --- Используем моковый initData для локальной разработки ---
                console.log('Режим локальной разработки: Отправка мокового X-Telegram-Init-Data');
                config.headers['X-Telegram-Init-Data'] = process.env.NEXT_PUBLIC_MOCK_INIT_DATA;
            } else {
                // Нормальный режим: пытаемся получить и отправить настоящий initData из Telegram Web App
                try {
                    const initData = window.Telegram?.WebApp?.initData;
                    if (initData) {
                        config.headers['X-Telegram-Init-Data'] = initData;
                    }
                } catch (e) {
                    console.error('Ошибка при получении initData:', e);
                }
            }
        }
        return config;
    },

    // ... (остальные перехватчики, если есть)
    (error) => {
        return Promise.reject(error);
    }
);


===== C:\Users\USER\Projects\robomine-capital\src\shared\api\index.ts =====

export { api } from './axios';


===== C:\Users\USER\Projects\robomine-capital\src\shared\assets\icons\Arrow.tsx =====

// @/shared/assets/icons/Arrow.tsx
export const Arrow = (props: React.SVGProps<SVGSVGElement>) => (
    <svg
        width="27"
        height="18"
        viewBox="0 0 27 18"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        {...props}
    >
        <path
            d="M12.9819 11.982L26.1602 11.982L26.1602 6.01816L12.9819 6.01814L12.9819 0.0387962L9.81912 0.0387946L0.857865 9.00005L9.81913 17.9613L12.9819 17.9613L12.9819 11.982Z"
            fill="currentColor"
        />
    </svg>
);


===== C:\Users\USER\Projects\robomine-capital\src\shared\assets\icons\Coin.tsx =====

// src/shared/assets/icons/Coin.tsx
import React from 'react';

export const Coin = ({
    width = 48,
    height = 48,
    className,
    ...props
}: React.SVGProps<SVGSVGElement> & { width?: number; height?: number }) => (
    <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="600 600 1200 1200"
        width={width}
        height={height}
        className={className}
        preserveAspectRatio="xMidYMid slice"
        {...props} // Передаем остальные пропсы (style, onClick и т.д.)
    >
        <path
            fillRule="evenodd"
            fill="rgb(99.21875%, 76.951599%, 20.776367%)"
            fillOpacity="1"
            d="M 1200 600.050781 C 1531.371094 600.050781 1800 868.679688 1800 1200.050781 C 1800 1531.425781 1531.371094 1800.054688 1200 1800.054688 C 868.628906 1800.054688 600 1531.425781 600 1200.050781 C 600 868.679688 868.628906 600.050781 1200 600.050781 "
        />
        <path
            fillRule="evenodd"
            fill="rgb(78.90625%, 53.318787%, 15.696716%)"
            fillOpacity="1"
            d="M 1200 720.058594 C 1465.089844 720.058594 1679.988281 934.960938 1679.988281 1200.050781 C 1679.988281 1465.144531 1465.089844 1680.042969 1200 1680.042969 C 934.90625 1680.042969 720.011719 1465.144531 720.011719 1200.050781 C 720.011719 934.960938 934.90625 720.058594 1200 720.058594 Z M 1200 752.339844 C 1447.269531 752.339844 1647.71875 952.789062 1647.71875 1200.050781 C 1647.71875 1447.320312 1447.269531 1647.769531 1200 1647.769531 C 952.730469 1647.769531 752.285156 1447.320312 752.285156 1200.050781 C 752.285156 952.789062 952.730469 752.339844 1200 752.339844 "
        />
        <path
            fillRule="evenodd"
            fill="rgb(99.21875%, 68.943787%, 18.821716%)"
            fillOpacity="1"
            d="M 1799.980469 1198.730469 L 1800 1200.050781 C 1800 1529.808594 1533.96875 1797.390625 1204.828125 1799.992188 L 1204.828125 1725.160156 C 1492.648438 1722.5625 1725.171875 1488.484375 1725.171875 1200.050781 L 1725.148438 1198.730469 L 1799.980469 1198.730469 "
        />
        <path
            fillRule="evenodd"
            fill="rgb(100%, 81.639099%, 31.37207%)"
            fillOpacity="1"
            d="M 620.121094 1046.050781 L 620.449219 1044.761719 C 705.796875 726.238281 1032.011719 536.628906 1350.609375 619.308594 L 1331.238281 691.589844 C 1052.558594 619.609375 767.382812 785.53125 692.730469 1064.128906 L 692.402344 1065.421875 L 620.121094 1046.050781 "
        />
        <path
            fillRule="evenodd"
            fill="rgb(94.921875%, 63.084412%, 17.259216%)"
            fillOpacity="1"
            d="M 1200 689.410156 C 1482.019531 689.410156 1710.648438 918.03125 1710.648438 1200.050781 C 1710.648438 1482.078125 1482.019531 1710.703125 1200 1710.703125 C 917.976562 1710.703125 689.351562 1482.078125 689.351562 1200.050781 C 689.351562 918.03125 917.976562 689.410156 1200 689.410156 Z M 1200 723.738281 C 1463.058594 723.738281 1676.308594 936.988281 1676.308594 1200.050781 C 1676.308594 1463.117188 1463.058594 1676.367188 1200 1676.367188 C 936.9375 1676.367188 723.6875 1463.117188 723.6875 1200.050781 C 723.6875 936.988281 936.9375 723.738281 1200 723.738281 "
        />
        <path
            fillRule="evenodd"
            fill="rgb(94.921875%, 63.084412%, 17.259216%)"
            fillOpacity="1"
            d="M 1014.910156 1217 C 1014.769531 1216.949219 1014.621094 1216.910156 1014.480469 1216.871094 C 1013.398438 1216.539062 1012.328125 1216.210938 1011.300781 1215.871094 C 1011.210938 1215.851562 1011.140625 1215.820312 1011.058594 1215.789062 C 1009.148438 1215.179688 1007.328125 1214.550781 1005.578125 1213.910156 C 1005.300781 1213.808594 1005.011719 1213.710938 1004.730469 1213.609375 C 1003.921875 1213.308594 1003.128906 1213.011719 1002.359375 1212.699219 C 1001.980469 1212.550781 1001.609375 1212.398438 1001.238281 1212.25 C 1000.578125 1211.980469 999.910156 1211.71875 999.277344 1211.449219 C 999.277344 1211.441406 999.277344 1211.429688 999.277344 1211.421875 C 999.277344 1192.140625 1063.589844 1175.851562 1152.648438 1170.109375 L 1152.648438 1218.539062 L 1172.609375 1236.460938 C 1162.980469 1236.21875 1156.101562 1235.921875 1152.648438 1235.75 C 1095.109375 1233.21875 1046.019531 1226.351562 1014.910156 1217 Z M 1423.960938 1198.660156 C 1423.941406 1198.679688 1423.929688 1198.710938 1423.921875 1198.738281 C 1423.570312 1199.28125 1423.171875 1199.820312 1422.730469 1200.359375 C 1422.691406 1200.398438 1422.660156 1200.449219 1422.621094 1200.488281 C 1422.171875 1201.019531 1421.671875 1201.558594 1421.121094 1202.078125 C 1421.070312 1202.128906 1421.03125 1202.171875 1420.988281 1202.210938 C 1420.421875 1202.738281 1419.808594 1203.28125 1419.140625 1203.808594 C 1419.101562 1203.828125 1419.070312 1203.859375 1419.03125 1203.890625 C 1418.339844 1204.429688 1417.601562 1204.96875 1416.800781 1205.511719 L 1416.78125 1205.519531 C 1396.328125 1219.261719 1342 1230.191406 1272.578125 1234.640625 L 1272.578125 1169.058594 C 1340.808594 1172.101562 1397.109375 1181.238281 1425.578125 1193.378906 C 1425.578125 1193.390625 1425.589844 1193.390625 1425.589844 1193.398438 C 1425.589844 1195.179688 1425.03125 1196.929688 1423.960938 1198.660156 Z M 1390.929688 991.460938 L 1390.910156 991.441406 L 1014.339844 991.441406 L 1014.339844 1083.609375 L 1034.410156 1101.628906 L 1152.628906 1101.628906 L 1152.628906 1144.03125 C 1040.230469 1149.191406 955.699219 1171.460938 955.699219 1198.140625 C 955.699219 1202.761719 958.234375 1207.25 963.011719 1211.539062 L 983.085938 1229.558594 C 1004.21875 1248.539062 1069.238281 1263.621094 1152.628906 1269.140625 L 1152.628906 1445.933594 L 1172.699219 1463.957031 L 1272.648438 1463.957031 L 1272.648438 1270.199219 C 1384.800781 1265.039062 1469.191406 1242.800781 1469.191406 1216.140625 C 1469.191406 1211.511719 1466.648438 1207.019531 1461.871094 1202.730469 L 1441.789062 1184.710938 C 1441.550781 1184.488281 1441.269531 1184.269531 1441.011719 1184.050781 C 1440.761719 1183.839844 1440.511719 1183.621094 1440.25 1183.410156 C 1439.511719 1182.808594 1438.738281 1182.21875 1437.921875 1181.628906 C 1437.789062 1181.539062 1437.671875 1181.441406 1437.539062 1181.351562 C 1436.53125 1180.640625 1435.460938 1179.941406 1434.328125 1179.25 C 1434.171875 1179.148438 1434 1179.050781 1433.828125 1178.949219 C 1432.851562 1178.359375 1431.820312 1177.769531 1430.75 1177.179688 C 1430.488281 1177.039062 1430.230469 1176.898438 1429.96875 1176.769531 C 1428.828125 1176.148438 1427.640625 1175.550781 1426.398438 1174.949219 C 1426.289062 1174.890625 1426.171875 1174.839844 1426.058594 1174.78125 C 1423.210938 1173.410156 1420.109375 1172.078125 1416.789062 1170.78125 C 1416.589844 1170.699219 1416.390625 1170.621094 1416.191406 1170.550781 C 1414.628906 1169.941406 1413.03125 1169.339844 1411.378906 1168.761719 C 1411.269531 1168.71875 1411.171875 1168.679688 1411.070312 1168.640625 C 1407.429688 1167.359375 1403.550781 1166.101562 1399.460938 1164.890625 C 1399.378906 1164.859375 1399.289062 1164.839844 1399.199219 1164.808594 C 1397.230469 1164.230469 1395.199219 1163.648438 1393.121094 1163.089844 C 1393.03125 1163.058594 1392.929688 1163.039062 1392.839844 1163.011719 C 1386.328125 1161.238281 1379.339844 1159.570312 1371.910156 1158 C 1371.828125 1157.980469 1371.738281 1157.960938 1371.660156 1157.941406 C 1364.191406 1156.371094 1356.289062 1154.898438 1347.988281 1153.539062 L 1347.839844 1153.511719 C 1325.371094 1149.828125 1300.019531 1146.980469 1272.679688 1145.171875 L 1272.679688 1101.628906 L 1410.988281 1101.628906 L 1410.988281 1009.46875 Z M 1448.828125 1195.449219 C 1448.710938 1194.941406 1448.550781 1194.421875 1448.371094 1193.910156 C 1448.390625 1193.921875 1448.398438 1193.929688 1448.410156 1193.941406 C 1448.578125 1194.441406 1448.71875 1194.941406 1448.828125 1195.449219 "
        />
        <path
            fillRule="evenodd"
            fill="rgba(202, 68, 255, 1)"
            fillOpacity="1"
            d="M 1252.601562 1235.75 C 1249.800781 1235.960938 1235.308594 1236.828125 1203 1236.828125 C 1177.300781 1236.828125 1159.050781 1236.058594 1152.648438 1235.75 C 1053.328125 1231.378906 979.203125 1214.101562 979.203125 1193.398438 C 979.203125 1172.699219 1053.328125 1155.429688 1152.648438 1150.988281 L 1152.648438 1218.539062 C 1159.148438 1219 1177.75 1220.101562 1203.441406 1220.101562 C 1234.28125 1220.101562 1249.730469 1218.820312 1252.511719 1218.558594 L 1252.511719 1151.039062 C 1351.621094 1155.449219 1425.589844 1172.738281 1425.589844 1193.398438 C 1425.589844 1214.050781 1351.640625 1231.339844 1252.511719 1235.730469 Z M 1252.601562 1144.050781 L 1252.601562 1083.609375 L 1390.910156 1083.609375 L 1390.910156 991.441406 L 1014.339844 991.441406 L 1014.339844 1083.609375 L 1152.628906 1083.609375 L 1152.628906 1144.03125 C 1040.230469 1149.191406 955.699219 1171.460938 955.699219 1198.140625 C 955.699219 1224.820312 1040.230469 1247.058594 1152.628906 1252.25 L 1152.628906 1445.933594 L 1252.578125 1445.933594 L 1252.578125 1252.179688 C 1364.71875 1247.011719 1449.109375 1224.769531 1449.109375 1198.121094 C 1449.109375 1171.460938 1364.789062 1149.21875 1252.578125 1144.03125 Z M 1252.601562 1144.050781 L 1252.601562 1144.050781 "
        />
    </svg>
);


===== C:\Users\USER\Projects\robomine-capital\src\shared\assets\icons\Copy.tsx =====

// @/shared/assets/icons/Copy.tsx
export const Copy = (props: React.SVGProps<SVGSVGElement>) => (
    <svg
        width="30"
        height="30"
        viewBox="0 0 30 30"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        {...props}
    >
        <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M6.40456 27.388C4.30997 27.388 2.61197 25.69 2.61197 23.5954V10.849C2.61197 8.7544 4.30997 7.05642 6.40456 7.05642H19.151C21.2456 7.05642 22.9436 8.7544 22.9436 10.849V23.5954C22.9436 25.69 21.2456 27.388 19.151 27.388H6.40456ZM0 23.5954C0 27.1326 2.86742 30 6.40456 30H19.151C22.6882 30 25.5556 27.1326 25.5556 23.5954V10.849C25.5556 7.31185 22.6882 4.44444 19.151 4.44444H6.40456C2.86742 4.44444 0 7.31184 0 10.849V23.5954Z"
            fill="currentColor"
        />
        <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M28.7232 20C29.4284 20 30 19.4284 30 18.7232V6.26146C30 2.80353 27.1967 0 23.7385 0H11.2768C10.5716 0 10 0.571648 10 1.27681C10 1.98197 10.5716 2.55362 11.2768 2.55362H23.7385C25.7863 2.55362 27.4464 4.2138 27.4464 6.26146V18.7232C27.4464 19.4284 28.018 20 28.7232 20Z"
            fill="currentColor"
        />
    </svg>
);


===== C:\Users\USER\Projects\robomine-capital\src\shared\assets\icons\Info.tsx =====

// @/shared/assets/icons/Arrow.tsx
export const Info = (props: React.SVGProps<SVGSVGElement>) => (
    <svg
        width="5"
        height="9"
        viewBox="0 0 5 9"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        {...props}
    >
        <path
            d="M2.9427 0.917038C2.9427 1.42351 2.47047 1.83408 1.88784 1.83408C1.30529 1.83408 0.833008 1.42351 0.833008 0.917038C0.833008 0.41057 1.30529 0 1.88784 0C2.47047 0 2.9427 0.41057 2.9427 0.917038Z"
            fill="currentColor"
        />
        <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M0.703234 2.88623C0.314849 2.88623 0 3.15994 0 3.49759C0 3.83523 0.314849 4.10895 0.703234 4.10895H2.1097V8.38846C2.1097 8.7261 2.42455 8.99981 2.81294 8.99981C2.84901 8.99981 2.88446 8.99745 2.91908 8.9929H4.29676C4.68515 8.9929 5 8.71918 5 8.38154C5 8.04389 4.68515 7.77018 4.29676 7.77018H3.51617V3.49759C3.51617 3.15994 3.20132 2.88623 2.81294 2.88623H0.703234Z"
            fill="currentColor"
        />
    </svg>
);


===== C:\Users\USER\Projects\robomine-capital\src\shared\assets\icons\Invite.tsx =====

// @/shared/assets/icons/Invite.tsx

export const Invite = (props: React.SVGProps<SVGSVGElement>) => (
    <svg
        width="16"
        height="16"
        viewBox="0 0 16 16"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        {...props}
    >
        <path
            d="M12.8696 11.8261V10.7826H11.8261V11.8261H10.7826V12.8696H11.8261V13.913H12.8696V12.8696H13.9131V11.8261H12.8696Z"
            fill="currentColor"
        />
        <path d="M16 10.7826H14.9565V13.913H16V10.7826Z" fill="currentColor" />
        <path
            d="M13.9131 14.9565H10.7826V16H13.9131V14.9565Z"
            fill="currentColor"
        />
        <path
            d="M13.9131 8.69556H10.7826V9.73903H13.9131V8.69556Z"
            fill="currentColor"
        />
        <path
            d="M9.73913 3.13044V2.08697H8.69566V1.04347H7.65219V0H3.13044V1.04347H2.08697V2.08697H1.04347V3.13044H0V7.65219H1.04347V8.69565H2.08697V9.73912H3.13044V10.7826H1.04347V11.8261H0V13.913H9.73913V10.7826H7.65219V9.73912H8.69566V8.69565H9.73913V7.65219H10.7826V3.13044H9.73913Z"
            fill="currentColor"
        />
        <path
            d="M10.7826 9.73914H9.73911V10.7826H10.7826V9.73914Z"
            fill="currentColor"
        />
        <path
            d="M14.9565 9.73914H13.913V10.7826H14.9565V9.73914Z"
            fill="currentColor"
        />
        <path
            d="M14.9565 13.913H13.913V14.9564H14.9565V13.913Z"
            fill="currentColor"
        />
        <path
            d="M10.7826 13.913H9.73911V14.9564H10.7826V13.913Z"
            fill="currentColor"
        />
    </svg>
);


===== C:\Users\USER\Projects\robomine-capital\src\shared\assets\icons\index.ts =====

export { Arrow } from './Arrow';
export { Invite } from './Invite';
export { Info } from './Info';
export { Coin } from './Coin';
export { Copy } from './Copy';


===== C:\Users\USER\Projects\robomine-capital\src\shared\config\env.ts =====

// shared/config/env.ts

export const API_URL = process.env.NEXT_PUBLIC_API_URL;


===== C:\Users\USER\Projects\robomine-capital\src\shared\config\index.ts =====

export { API_URL } from './env';


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\contexts\MachineContext.tsx =====

'use client';

// @/shared/lib/contexts/MachineContext.tsx
import React, {
    ReactNode,
    createContext,
    useCallback,
    useContext,
    useEffect,
    useState,
} from 'react';
import { MachineWithState, getAllMachines } from '@/entities/machine';

// Определяем возможные статусы машины
// Предполагается, что они совпадают с теми, что в MachineToUserAttributes
// Если они определены где-то как тип или константы, лучше импортировать оттуда
type MachineStatus =
    | 'not_purchased'
    | 'awaiting'
    | 'in_progress'
    | 'waiting_for_reward'
    | 'completed';

interface MachineContextType {
    machines: MachineWithState[];
    loading: boolean;
    error: string | null;
    refreshMachines: () => Promise<void>;
    // Обновляет любые поля машины
    updateMachineLocally: (machineId: number, updates: Partial<MachineWithState>) => void;
    // Обновляет статус машины (если state_car существует)
    updateMachineStatusLocally: (machineId: number, newStatus: MachineStatus) => void;
    // Обновляет конкретные поля state_car (если он существует)
    updateMachineStateCarLocally: (
        machineId: number,
        updates: Partial<NonNullable<MachineWithState['state_car']>>
    ) => void;
    // Новый метод для обновления remaining_uses
    updateMachineRemainingUses: (machineId: number, newRemainingUses: number) => void;
}

const MachineContext = createContext<MachineContextType | undefined>(undefined);

export const MachineProvider = ({ children }: { children: ReactNode }) => {
    const [machines, setMachines] = useState<MachineWithState[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    const refreshMachines = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);
            const fetchedMachines = await getAllMachines();
            setMachines(fetchedMachines);
        } catch (err) {
            console.error('Ошибка при обновлении списка машин:', err);
            setError('Не удалось обновить список машин');
        } finally {
            setLoading(false);
        }
    }, []);

    // Точечное обновление машины без перезагрузки всего списка
    const updateMachineLocally = useCallback(
        (machineId: number, updates: Partial<MachineWithState>) => {
            setMachines((prevMachines) =>
                prevMachines.map((machine) => {
                    if (machine.car.id === machineId) {
                        // Создаем поверхностную копию и применяем обновления
                        return { ...machine, ...updates };
                    }
                    return machine;
                })
            );
        },
        []
    );

    // Обновление только статуса (только если state_car существует)
    const updateMachineStatusLocally = useCallback(
        (machineId: number, newStatus: MachineStatus) => {
            setMachines((prevMachines) =>
                prevMachines.map((machine) => {
                    // Проверяем, что state_car существует, прежде чем обновлять
                    if (machine.car.id === machineId && machine.state_car) {
                        return {
                            ...machine,
                            state_car: {
                                ...machine.state_car,
                                status: newStatus,
                            },
                        };
                    }
                    return machine;
                })
            );
        },
        []
    );

    // Обновление конкретных полей state_car (только если он существует)
    const updateMachineStateCarLocally = useCallback(
        (machineId: number, updates: Partial<NonNullable<MachineWithState['state_car']>>) => {
            setMachines((prevMachines) =>
                prevMachines.map((machine) => {
                    // Проверяем, что state_car существует, прежде чем обновлять
                    if (machine.car.id === machineId && machine.state_car) {
                        return {
                            ...machine,
                            state_car: {
                                ...machine.state_car,
                                ...updates,
                            },
                        };
                    }
                    return machine;
                })
            );
        },
        []
    );

    // Новый метод для обновления remaining_uses
    const updateMachineRemainingUses = useCallback(
        (machineId: number, newRemainingUses: number) => {
            setMachines((prevMachines) =>
                prevMachines.map((machine) => {
                    // Проверяем, что state_car существует, прежде чем обновлять
                    if (machine.car.id === machineId && machine.state_car) {
                        return {
                            ...machine,
                            state_car: {
                                ...machine.state_car,
                                remaining_uses: newRemainingUses,
                            },
                        };
                    }
                    return machine;
                })
            );
        },
        []
    );

    useEffect(() => {
        refreshMachines();
    }, [refreshMachines]);

    // --- КРИТИЧЕСКИ ВАЖНО: useMemo для value ---
    const contextValue = React.useMemo(
        () => ({
            // <-- useMemo
            machines,
            loading,
            error,
            refreshMachines,
            updateMachineLocally,
            updateMachineStatusLocally,
            updateMachineStateCarLocally,
            updateMachineRemainingUses,
        }),
        [
            machines,
            loading,
            error,
            refreshMachines,
            updateMachineLocally,
            updateMachineStatusLocally,
            updateMachineStateCarLocally,
            updateMachineRemainingUses,
        ]
    );
    // --- КОНЕЦ КРИТИЧЕСКОЙ ЧАСТИ ---

    return (
        <MachineContext.Provider value={contextValue}>
            {/* <-- Передаем мемоизированное значение */}
            {children}
        </MachineContext.Provider>
    );
};

export const useMachines = (): MachineContextType => {
    const context = useContext(MachineContext);
    if (!context) {
        throw new Error('useMachines must be used within a MachineProvider');
    }
    return context;
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\contexts\ReferralContext.tsx =====

'use client';

// src/shared/lib/contexts/ReferralContext.tsx
import React, {
    ReactNode,
    createContext,
    useCallback,
    useContext,
    useEffect,
    useState,
} from 'react';
import { UserReferralData, getUserReferrals } from '@/entities/user';
import { useUser } from '@/shared/lib/contexts';

// 1. Определяем интерфейс контекста
interface ReferralContextType {
    referralsData: UserReferralData | null;
    isLoading: boolean;
    error: string | null;
    refreshReferrals: () => Promise<void>;
}

// 2. Создаем контекст
const ReferralContext = createContext<ReferralContextType | undefined>(undefined);

// 3. Создаем провайдер
export const ReferralProvider = ({ children }: { children: ReactNode }) => {
    // 4. Состояния для данных, загрузки и ошибок
    const [referralsData, setReferralsData] = useState<UserReferralData | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // 5. Получаем пользователя из UserContext, чтобы знать, когда начинать загрузку
    const { user } = useUser();

    // 6. Функция для загрузки данных рефералов
    const fetchReferralsData = useCallback(async () => {
        if (!user) {
            // Если пользователя нет, сбрасываем данные и состояние
            setReferralsData(null);
            setIsLoading(false);
            setError(null);
            return;
        }

        try {
            setIsLoading(true);
            setError(null);
            const data = await getUserReferrals();
            setReferralsData(data);
        } catch {
            setError('Не удалось загрузить данные рефералов');
            // Сбрасываем данные в случае ошибки
            setReferralsData(null);
        } finally {
            setIsLoading(false);
        }
    }, [user]); // Зависимость от user

    // 7. Функция для обновления данных
    const refreshReferrals = useCallback(async () => {
        await fetchReferralsData();
    }, [fetchReferralsData]);

    // 8. Эффект для загрузки данных при монтировании и изменении пользователя
    useEffect(() => {
        fetchReferralsData();
    }, [fetchReferralsData]);

    // 9. Мемоизация значения контекста для оптимизации
    const contextValue = React.useMemo(
        () => ({
            referralsData,
            isLoading,
            error,
            refreshReferrals,
        }),
        [referralsData, isLoading, error, refreshReferrals]
    );

    // 10. Предоставляем значение контекста дочерним компонентам
    return <ReferralContext.Provider value={contextValue}>{children}</ReferralContext.Provider>;
};

// 11. Создаем хук для удобного использования контекста
export const useReferrals = (): ReferralContextType => {
    const context = useContext(ReferralContext);
    if (context === undefined) {
        throw new Error('useReferrals must be used within a ReferralProvider');
    }
    return context;
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\contexts\TimerContext.tsx =====

'use client';

// @/shared/lib/contexts/TimerContext.tsx
import React, {
    ReactNode,
    createContext,
    useCallback,
    useContext,
    useEffect,
    useRef,
    useState,
} from 'react';
import { useMachines } from '@/shared/lib/contexts/MachineContext';

// Добавляем импорт

interface TimerData {
    timeLeftFormatted: string;
    progress: number;
    isActive: boolean;
}

interface TimerContextType {
    timers: Record<number, TimerData>;
    startTimer: (machineId: number, lastUpdated: number, workTime: number) => void;
    stopTimer: (machineId: number) => void;
    getTimer: (machineId: number) => TimerData | undefined;
    isTimerActive: (machineId: number) => boolean;
}

const TimerContext = createContext<TimerContextType | undefined>(undefined);

export const TimerProvider = ({ children }: { children: ReactNode }) => {
    const [timers, setTimers] = useState<Record<number, TimerData>>({});
    const intervalsRef = useRef<Record<number, NodeJS.Timeout>>({});
    const { updateMachineStatusLocally } = useMachines(); // Получаем метод обновления статуса

    const getWorkTime = useCallback((): number => {
        const workTime = Number(process.env.NEXT_PUBLIC_CAR_WORK_TIME);
        return isNaN(workTime) ? 30 : workTime;
    }, []);

    const getTimer = useCallback(
        (machineId: number): TimerData | undefined => {
            return timers[machineId];
        },
        [timers]
    );

    const isTimerActive = useCallback((machineId: number): boolean => {
        return !!intervalsRef.current[machineId];
    }, []);

    const stopTimer = useCallback((machineId: number) => {
        if (intervalsRef.current[machineId]) {
            clearInterval(intervalsRef.current[machineId]);
            delete intervalsRef.current[machineId];
        }

        setTimers((prev) => {
            const newTimers = { ...prev };
            delete newTimers[machineId];
            return newTimers;
        });
    }, []);

    const startTimer = useCallback(
        (machineId: number, lastUpdated: number, workTime: number) => {
            // Если таймер уже активен, не перезапускаем его
            if (intervalsRef.current[machineId]) {
                return;
            }

            const endTime = lastUpdated + workTime;

            const updateTimer = () => {
                const now = Math.floor(Date.now() / 1000);
                const remainingSeconds = Math.max(0, endTime - now);
                const elapsedSeconds = Math.max(0, now - lastUpdated);

                // Рассчитываем прогресс в процентах
                const progressPercent = Math.min(100, (elapsedSeconds / workTime) * 100);

                // Форматируем оставшееся время в HH:MM:SS
                const hours = Math.floor(remainingSeconds / 3600);
                const minutes = Math.floor((remainingSeconds % 3600) / 60);
                const seconds = remainingSeconds % 60;

                const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes
                    .toString()
                    .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                // Обновляем состояние таймера
                setTimers((prev) => ({
                    ...prev,
                    [machineId]: {
                        timeLeftFormatted: formattedTime,
                        progress: progressPercent,
                        isActive: remainingSeconds > 0,
                    },
                }));

                // Если время вышло, останавливаем таймер и обновляем статус машины
                if (remainingSeconds <= 0) {
                    stopTimer(machineId);
                    // Обновляем статус машины на 'waiting_for_reward'
                    updateMachineStatusLocally(machineId, 'waiting_for_reward');
                }
            };

            // Первый запуск немедленно
            updateTimer();

            // Запускаем интервал
            intervalsRef.current[machineId] = setInterval(updateTimer, 1000);
        },
        [stopTimer, updateMachineStatusLocally]
    );

    // Очищаем все интервалы при размонтировании
    useEffect(() => {
        // Копируем текущие интервалы в локальную переменную
        const intervalsToClear = { ...intervalsRef.current };

        return () => {
            Object.values(intervalsToClear).forEach(clearInterval);
        };
    }, []);

    // Значение контекста
    const contextValue = React.useMemo(
        () => ({
            timers,
            startTimer,
            stopTimer,
            getTimer,
            isTimerActive,
        }),
        [timers, startTimer, stopTimer, getTimer, isTimerActive]
    );

    return <TimerContext.Provider value={contextValue}>{children}</TimerContext.Provider>;
};

export const useTimers = (): TimerContextType => {
    const context = useContext(TimerContext);
    if (!context) {
        throw new Error('useTimers must be used within a TimerProvider');
    }
    return context;
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\contexts\UserContext.tsx =====

'use client';

// src/entities/user/model/UserContext.tsx (фрагмент)
import React, {
    ReactNode,
    createContext,
    useCallback,
    useContext,
    useEffect,
    useState,
} from 'react';
import { UserAttributes, getMe } from '@/entities/user';
import { useTelegramWebApp } from '@/shared/lib/hooks/useTelegramWebApp';

interface UserContextType {
    user: UserAttributes | null;
    isLoading: boolean;
    error: string | null;
    refreshUser: () => Promise<void>;
    refreshUserBalance: () => Promise<void>;
    updateUserLocally: (updates: Partial<UserAttributes>) => void;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export const UserProvider = ({ children }: { children: ReactNode }) => {
    const [user, setUser] = useState<UserAttributes | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const { tgUser, isLoading: isTgLoading } = useTelegramWebApp();

    const fetchUserData = useCallback(async () => {
        // <-- useCallback для fetchUserData
        if (!tgUser?.id) return;
        try {
            setIsLoading(true);
            setError(null);
            const userData = await getMe();
            setUser(userData);
            if (typeof window !== 'undefined') {
                window.telegramUser = userData;
            }
        } catch (err) {
            console.error('Ошибка загрузки данных пользователя:', err);
            setError('Не удалось загрузить данные пользователя');
        } finally {
            setIsLoading(false);
        }
    }, [tgUser?.id]); // Зависит от tgUser.id

    const refreshUserBalance = useCallback(async () => {
        // <-- useCallback
        if (!user) return;
        try {
            const updatedUser = await getMe();
            setUser(updatedUser); // Или точечное обновление, если нужно
        } catch (err) {
            console.error('Ошибка обновления баланса:', err);
        }
    }, [user]); // Зависит от user

    const refreshUser = useCallback(async () => {
        // <-- useCallback
        await fetchUserData();
    }, [fetchUserData]); // Зависит от fetchUserData

    const updateUserLocally = useCallback((updates: Partial<UserAttributes>) => {
        // <-- useCallback
        setUser((prevUser) => {
            if (!prevUser) return null;
            return { ...prevUser, ...updates };
        });
    }, []); // Не зависит от внешних переменных, кроме setUser

    useEffect(() => {
        if (!isTgLoading && tgUser?.id) {
            fetchUserData();
        } else if (!isTgLoading && !tgUser?.id) {
            setIsLoading(false);
        }
    }, [tgUser, isTgLoading, fetchUserData]); // Добавлен fetchUserData в зависимости

    // --- КРИТИЧЕСКИ ВАЖНО: useCallback для всего value ---
    const contextValue = React.useMemo(
        () => ({
            // <-- useMemo для value
            user,
            isLoading,
            error,
            refreshUser,
            refreshUserBalance,
            updateUserLocally,
        }),
        [user, isLoading, error, refreshUser, refreshUserBalance, updateUserLocally]
    );
    // --- КОНЕЦ КРИТИЧЕСКОЙ ЧАСТИ ---

    return <UserContext.Provider value={contextValue}>{children}</UserContext.Provider>;
};

export const useUser = (): UserContextType => {
    const context = useContext(UserContext);
    if (context === undefined) {
        throw new Error('useUser must be used within a UserProvider');
    }
    return context;
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\contexts\index.ts =====

export { MachineProvider, useMachines } from './MachineContext';
export { UserProvider, useUser } from './UserContext';
export { ReferralProvider, useReferrals } from './ReferralContext';


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\hooks\useTelegramWebApp.ts =====

// shared/lib/hooks/useTelegramWebApp.ts
import { useEffect, useState } from 'react';

interface TelegramUser {
    id: number;
    first_name: string;
    last_name?: string;
    username?: string;
    language_code?: string;
    photo_url?: string;
}

// Объявляем глобальный тип для Telegram WebApp
declare global {
    interface Window {
        Telegram?: {
            WebApp: {
                initDataUnsafe: {
                    user?: TelegramUser;
                };
                initData?: string; // Для проверки в других частях приложения, если нужно
                disableVerticalSwipes: () => void;
                ready: () => void;
                expand: () => void;
                platform?: string;
            };
        };
    }
}

export const useTelegramWebApp = () => {
    const [tgUser, setTgUser] = useState<TelegramUser | null>(null);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        // Проверяем, локальная ли разработка
        const isLocalhost =
            typeof window !== 'undefined' &&
            (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');

        if (isLocalhost) {
            console.log('LOCALHOST detected in useTelegramWebApp');

            // Используем фиксированный ID для локальной разработки
            // Убедитесь, что этот ID соответствует пользователю в вашей БД
            // и совпадает с ID, используемым в NEXT_PUBLIC_MOCK_INIT_DATA на бэкенде
            const MOCK_TELEGRAM_USER_ID = 912131238; // Ваш ID

            const mockUser: TelegramUser = {
                id: MOCK_TELEGRAM_USER_ID,
                first_name: 'Александр', // Имя из вашего initData
                last_name: '', // Фамилия из вашего initData
                username: 'v3r3tnxv', // Username из вашего initData
                language_code: 'ru', // Язык из вашего initData
                // Добавьте другие поля, если они используются в вашем приложении
                // photo_url: 'https://t.me/i/userpic/320/....svg' // Из вашего initData
            };

            console.log('Setting mock tgUser:', mockUser);
            setTgUser(mockUser);
            setIsLoading(false);
            return;
        }

        // Логика для production (внутри Telegram Web App)
        if (typeof window !== 'undefined' && window.Telegram?.WebApp) {
            // Получаем данные пользователя из Telegram Web App
            const user = window.Telegram.WebApp.initDataUnsafe?.user || null;
            setTgUser(user);
            setIsLoading(false);

            // Раскрываем приложение на весь экран
            try {
                window.Telegram.WebApp.disableVerticalSwipes();
                window.Telegram.WebApp.expand();
                window.Telegram.WebApp.ready();
            } catch (e) {
                console.warn('Error expanding Telegram WebApp:', e);
            }
        } else {
            setTgUser(null);
            setIsLoading(false);
        }
    }, []); // Пустой массив зависимостей - запускается только при монтировании

    return { tgUser, isLoading };
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\index.ts =====

// export * from './hooks';
export * from './';


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\providers\AppProviders.tsx =====

'use client';

// app/appProviders.tsx
import { useState } from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
// import { SplashScreen } from '@/shared/ui';
import { MachineProvider, UserProvider } from '../contexts';
import { ReferralProvider } from '../contexts/ReferralContext';
import { TimerProvider } from '../contexts/TimerContext';

export function AppProviders({ children }: { children: React.ReactNode }) {
    const [queryClient] = useState(
        () =>
            new QueryClient({
                defaultOptions: {
                    queries: {
                        staleTime: 60 * 1000,
                    },
                },
            })
    );

    // const [showSplash, setShowSplash] = useState(true);

    // // Эффект для установки таймера
    // useEffect(() => {
    //     const timer = setTimeout(() => {
    //         setShowSplash(false); // Через 5 секунд скрываем сплеш
    //     }, 3000); // 5000 миллисекунд = 5 секунд

    //     // Очистка таймера при размонтировании (хорошая практика)
    //     return () => clearTimeout(timer);
    // }, []); // Пустой массив зависимостей - запускается только при монтировании

    // // Если showSplash true, рендерим только экран загрузки
    // if (showSplash) {
    //     return <SplashScreen />; // <-- Отображаем SplashScreen
    // }

    return (
        <QueryClientProvider client={queryClient}>
            <UserProvider>
                <ReferralProvider>
                    <MachineProvider>
                        <TimerProvider>{children}</TimerProvider>
                    </MachineProvider>
                </ReferralProvider>
            </UserProvider>
        </QueryClientProvider>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\shared\lib\providers\index.ts =====

export { AppProviders } from './AppProviders';


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\back-button\BackButton.tsx =====

'use client';

// @/shared/ui/back-button/BackButton.tsx
import { useRouter } from 'next/navigation';
import { Arrow } from '@/shared/assets/icons';
import styles from './BackButton.module.scss';

export const BackButton = () => {
    const router = useRouter();

    return (
        <button
            className={styles.backButton}
            onClick={() => router.back()}
            aria-label="Назад"
            type="button"
            title="Назад"
        >
            <Arrow className={styles.icon} />
        </button>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\back-button\index.ts =====

export { BackButton } from './BackButton';


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\button\Button.tsx =====

import clsx from 'clsx';
import styles from './Button.module.scss';
import { ButtonProps } from './types';

export const Button = ({
    label,
    onClick,
    disabled = false,
    variant = 'primary',
    children,
    className,
    ...props
}: ButtonProps) => {
    const variantClass = styles[`button${variant[0].toUpperCase() + variant.slice(1)}`];

    return (
        <button
            className={clsx(styles.button, variantClass, className, {
                [styles.disabled]: disabled,
            })}
            onClick={onClick}
            disabled={disabled}
            {...props}
        >
            {children}
            {label}
        </button>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\button\index.ts =====

export { Button } from "./Button";

===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\button\types.ts =====

export type Buttonvariant = 'primary' | 'secondary' | 'switch' | 'info' | 'outline';

export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    label?: string;
    children?: React.ReactNode;
    variant?: Buttonvariant;
    className?: string;
}


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\index.ts =====

export { Button } from './button';
export { InfoButton } from './info-button';
export { BackButton } from './back-button';
export { Modal } from './modal';
export { Input } from './input';
export { ProgressBar } from './progres-bar';
export { SplashScreen } from './splash-screen';


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\info-button\InfoButton.tsx =====

import clsx from 'clsx';
import '@/shared/assets/icons';
import { Info } from '@/shared/assets/icons';
import styles from './InfoButton.module.scss';
import { InfoButtonProps } from './types';

export const InfoButton = ({ onClick, className }: InfoButtonProps) => {
    return (
        <button
            type="button"
            className={clsx(styles.infoButton, className)}
            onClick={onClick}
            title="Подробнее"
            aria-label="Подробнее"
        >
            <Info className={styles.icon} />
        </button>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\info-button\index.ts =====

export { InfoButton } from "./InfoButton";

===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\info-button\types.ts =====

export interface InfoButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    className?: string;
}


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\input\Input.tsx =====

// @/shared/ui/input/Input.tsx
import clsx from 'clsx';
import styles from './Input.module.scss';
import { InputProps } from './types';

export const Input = ({
    type = 'text',
    placeholder,
    value,
    onChange,
    error,
    disabled,
    className,
    variant = 'default',
    currency,
    ...props
}: InputProps) => {
    if (variant === 'balance') {
        return (
            <div
                className={clsx(
                    styles.inputWrapper,
                    styles.balanceWrapper,
                    error && styles.error,
                    disabled && styles.disabled
                )}
            >
                <input
                    type={type}
                    className={clsx(styles.input, styles.balanceInput, className)}
                    placeholder={placeholder}
                    value={value}
                    onChange={onChange}
                    disabled={disabled}
                    {...props}
                />
                {currency && <span className={styles.currency}>{currency}</span>}
                {error && <span className={styles.errorMessage}>{error}</span>}
            </div>
        );
    }

    // Обычный инпут
    return (
        <div
            className={clsx(
                styles.inputWrapper,
                error && styles.error,
                disabled && styles.disabled,
                className
            )}
        >
            <input
                type={type}
                className={clsx(styles.input, error && styles.errorInput)}
                placeholder={placeholder}
                value={value}
                onChange={onChange}
                disabled={disabled}
                {...props}
            />
            {error && <span className={styles.errorMessage}>{error}</span>}
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\input\index.ts =====

export { Input } from './Input';


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\input\types.ts =====

// @/shared/ui/input/types.ts
export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
    error?: string;
    variant?: 'default' | 'balance'; // Добавляем вариант
    currency?: string; // Валюта для баланса
}


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\maintenance-screen\MaintenanceScreen.tsx =====

// src/shared/ui/MaintenanceScreen/MaintenanceScreen.tsx
'use client';

import React, { useEffect, useState } from 'react';
import Image from 'next/image';
import styles from './MaintenanceScreen.module.scss';

// src/shared/ui/MaintenanceScreen/MaintenanceScreen.tsx

// src/shared/ui/MaintenanceScreen/MaintenanceScreen.tsx

// src/shared/ui/MaintenanceScreen/MaintenanceScreen.tsx

export const MaintenanceScreen: React.FC = () => {
    // Список сообщений о процессе технических работ, тематических для майнинга
    const maintenanceMessages = [
        'Проверяем работоспособность майнинг-ферм...',
        'Обновляем прошивку оборудования...',
        'Запускаем диагностику ASIC чипов...',
        'Оптимизируем алгоритмы майнинга...',
        'Настраиваем охлаждение систем...',
        'Заряжаем майнинг-машины...',
        'Синхронизируем с блокчейном...',
        'Проверяем подключение к пулам...',
        'Калибруем энергопотребление...',
        'Загружаем последние обновления...',
        'Готовим роботов-операторов...',
        'Подготавливаем награды для пользователей...',
        'Финальная проверка систем...',
    ];

    const [currentMessageIndex, setCurrentMessageIndex] = useState(0);
    const [progress, setProgress] = useState(0);
    const [isCompleted, setIsCompleted] = useState(false);

    // Циклическая смена сообщений
    useEffect(() => {
        const messageInterval = setInterval(() => {
            setCurrentMessageIndex((prevIndex) => (prevIndex + 1) % maintenanceMessages.length);
        }, 3000); // Меняем сообщение каждые 3 секунды

        return () => clearInterval(messageInterval);
    }, [maintenanceMessages.length]);

    // Анимация прогресс-бара (имитация работы)
    useEffect(() => {
        const progressInterval = setInterval(() => {
            setProgress((prev) => {
                const newProgress = prev + Math.random() * 5; // Случайный прирост
                if (newProgress >= 100) {
                    setIsCompleted(true);
                    clearInterval(progressInterval);
                    return 100;
                }
                return newProgress;
            });
        }, 500);

        return () => clearInterval(progressInterval);
    }, []);

    return (
        <div className={styles.maintenanceScreen}>
            <div className={styles.content}>
                {/* Анимированный робот-механик */}
                <div className={styles.robotContainer}>
                    <Image
                        src="/images/mascot.webp" // Используй подходящее изображение
                        alt="Робот-механик"
                        width={120}
                        height={120}
                        className={styles.robot}
                        priority
                    />
                    {/* Иконки процесса вокруг робота */}
                    <div className={styles.processIcons}>
                        <span className={styles.icon1}>⚙️</span>
                        <span className={styles.icon2}>⚡</span>
                        <span className={styles.icon3}>🛠️</span>
                    </div>
                </div>

                {/* Заголовок */}
                <h1 className={styles.title}>
                    <span className={styles.highlight}>Технические работы</span>
                </h1>

                {/* Динамическое сообщение о процессе */}
                <div className={styles.messageContainer}>
                    <p className={styles.message}>{maintenanceMessages[currentMessageIndex]}</p>
                    <div className={styles.typingIndicator}>
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            </div>

            {/* Анимированный фон */}
            <div className={styles.animatedBackground}>
                {[...Array(20)].map((_, i) => (
                    <div
                        key={i}
                        className={styles.floatingElement}
                        style={{
                            left: `${Math.random() * 100}%`,
                            animationDelay: `${Math.random() * 5}s`,
                            animationDuration: `${15 + Math.random() * 10}s`,
                        }}
                    >
                        {['⛏️', '⚡', '💻', '🔧', '⚙️'][Math.floor(Math.random() * 5)]}
                    </div>
                ))}
            </div>
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\modal\Modal.tsx =====

'use client';

// @/shared/ui/modal/Modal.tsx
import { useEffect } from 'react';
import styles from './Modal.module.scss';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    children: React.ReactNode;
}

export const Modal = ({ isOpen, onClose, children }: ModalProps) => {
    // Закрываем модалку при нажатии Escape
    useEffect(() => {
        const handleEscape = (e: KeyboardEvent) => {
            if (e.key === 'Escape') {
                onClose();
            }
        };

        if (isOpen) {
            document.addEventListener('keydown', handleEscape);
            // Предотвращаем скролл фона при открытом модальном окне
            document.body.style.overflow = 'hidden';
        }

        return () => {
            document.removeEventListener('keydown', handleEscape);
            document.body.style.overflow = 'unset';
        };
    }, [isOpen, onClose]);

    if (!isOpen) return null;

    const handleBackdropClick = (e: React.MouseEvent) => {
        if (e.target === e.currentTarget) {
            onClose();
        }
    };

    return (
        <div className={styles.modalBackdrop} onClick={handleBackdropClick}>
            <button className={styles.closeButton} onClick={onClose} aria-label="Закрыть">
                ×
            </button>
            <div className={styles.modalContent}>{children}</div>
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\modal\index.ts =====

export { Modal } from './Modal';


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\progres-bar\ProgressBar.tsx =====

'use client';

import { memo } from 'react';
import clsx from 'clsx';
import styles from './ProgressBar.module.scss';

interface ProgressBarProps {
    progress: number;
    className?: string;
}

export const ProgressBar = memo(({ progress, className }: ProgressBarProps) => {
    return (
        <div className={clsx(styles.progressBar, className)}>
            <div className={styles.progressFill} style={{ width: `${progress}%` }} />
        </div>
    );
});

ProgressBar.displayName = 'ProgressBar';


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\progres-bar\index.ts =====

export { ProgressBar } from './ProgressBar';


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\splash-screen\SplashScreen.tsx =====

'use client';

// src/shared/ui/splash-screen/SplashScreen.tsx
import { useEffect, useState } from 'react';
import { ProgressBar } from '../progres-bar';
import styles from './SplashScreen.module.scss';

export function SplashScreen() {
    const [progress, setProgress] = useState(0);

    useEffect(() => {
        // Общее время показа SplashScreen в миллисекундах
        const TOTAL_DURATION_MS = 500; // 3 секунды
        // Интервал обновления в миллисекундах
        const INTERVAL_TIME_MS = 5;

        // Рассчитываем, на сколько процентов увеличивать прогресс за каждый шаг
        // 100% / (TOTAL_DURATION_MS / INTERVAL_TIME_MS) = 100% / (3000 / 50) = 100% / 60 = 1.666...%
        const INCREMENT_PER_STEP = 100 / (TOTAL_DURATION_MS / INTERVAL_TIME_MS);

        const interval = setInterval(() => {
            setProgress((prevProgress) => {
                const newProgress = prevProgress + INCREMENT_PER_STEP;
                // Если прогресс достиг или превысил 100%, останавливаем интервал
                if (newProgress >= 100) {
                    clearInterval(interval);
                    return 100;
                }
                return newProgress;
            });
        }, INTERVAL_TIME_MS);

        // Функция очистки: очищаем интервал, когда компонент размонтируется
        return () => clearInterval(interval);
    }, []);

    return (
        <div className={styles.splashSceen}>
            <p className={styles.label}>Загрузка...</p>
            <ProgressBar className={styles.progressBar} progress={progress} />
        </div>
    );
}


===== C:\Users\USER\Projects\robomine-capital\src\shared\ui\splash-screen\index.ts =====

// src/shared/ui/splash-screen/index.ts
export { SplashScreen } from './SplashScreen';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\action-buttons\index.ts =====

export { ActionButtons } from './ui/ActionButtons';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\action-buttons\ui\ActionButtons.tsx =====

import Link from 'next/link';
import { Arrow, Invite } from '@/shared/assets/icons';
import styles from './ActionButtons.module.scss';

const actions = [
    {
        key: 'deposit',
        href: '/deposit',
        icon: <Arrow className={styles.icon} />,
        label: 'Пополнить',
    },
    {
        key: 'withdraw',
        href: '/withdraw',
        icon: <Arrow className={styles.icon} />,
        label: 'Вывести',
    },
    {
        key: 'referral',
        href: '/referral',
        icon: <Invite className={styles.icon} />,
        label: 'Пригласить',
    },
];

export const ActionButtons = () => {
    return (
        <div className={styles.actions}>
            {actions.map(({ key, href, icon, label }) => (
                <Link key={key} href={href} className={styles[key]}>
                    <div className={styles.iconWrapper}>{icon}</div>
                    <span className={styles.label}>{label}</span>
                </Link>
            ))}
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\balance\index.ts =====

export { Balance } from './ui/Balance';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\balance\ui\Balance.tsx =====

'use client';

// src/widgets/balance/ui/Balance.tsx
import CountUp from 'react-countup';
import { convertCurrency, useCurrencyConverter } from '@/features/currency-converter';
import { Coin } from '@/shared/assets/icons';
import { useUser } from '@/shared/lib/contexts/UserContext';
import styles from './Balance.module.scss';

export const Balance = () => {
    const { user } = useUser();
    const { rates } = useCurrencyConverter();

    const userBalance =
        user?.balance !== undefined && user?.balance !== null ? Number(user.balance) : 0;

    const balanceRub = rates
        ? convertCurrency({
              amount: userBalance,
              from: 'USDT',
              to: 'RUB',
              rates: rates,
          })
        : 0;

    const formattedBalanceRub = balanceRub.toFixed(2);
    const formattedBalanceUSDT = userBalance.toFixed(2);

    return (
        <div className={styles.balance}>
            <div className={styles.balanceRUB}>
                <CountUp
                    end={parseFloat(formattedBalanceRub)}
                    decimals={2}
                    duration={0.5}
                    separator=" "
                    decimal="."
                    prefix=""
                    suffix=" "
                />
                <span>₽</span>
            </div>
            <div className={styles.balanceUSDT}>
                <CountUp
                    end={parseFloat(formattedBalanceUSDT)} // Преобразуем в число
                    decimals={2}
                    duration={0.5} // Продолжительность анимации в секундах
                    separator=" " // Разделитель тысяч (если нужно)
                    decimal="."
                    prefix="" // Префикс (если нужен, например, "$")
                    suffix=" "
                    className={styles.value}
                />
                <Coin width={40} height={40} />
            </div>
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\by-machine-link\BuyMachineLink.tsx =====

// @/widgets/machine-card/ui/BuyMoreCard.tsx
import Image from 'next/image';
import Link from 'next/link';
import styles from './BuyMachineLink.module.scss';

export const BuyMachineLink = () => {
    return (
        <Link className={styles.shopLink} href="/shop">
            <div className={styles.imageWrapper}>
                <Image
                    src="/images/mascot.webp"
                    width={100}
                    height={100}
                    alt="Робот"
                    className={styles.mascotImage}
                    priority
                />
            </div>
            <span className={styles.label}>Купить майнинг-машину</span>
        </Link>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\by-machine-link\index.ts =====

export { BuyMachineLink } from './BuyMachineLink';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\header\index.ts =====

export { Header } from './ui/Header';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\header\ui\Header.tsx =====

import { Balance } from '@/widgets/balance';
import { User } from '@/widgets/user';
import styles from './Header.module.scss';

export const Header = () => {
    return (
        <header className={styles.header}>
            <User />
            <Balance />
        </header>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-card\index.ts =====

export * from './model/';
export * from './ui/';

===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-card\model\index.ts =====

export type { MachineCardProps, MachineInfoModalProps } from './types';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-card\model\machines.ts =====

// @/widgets/machine-card/model/machines.ts
export const MACHINES = [
    {
        id: 1,
        imageType: 1,
        price: 15,
    },
    {
        id: 2,
        imageType: 3,
        price: 150,
    },
    {
        id: 3,
        imageType: 3,
        price: 500,
    },
    {
        id: 4,
        imageType: 4,
        price: 1000,
    },
    {
        id: 5,
        imageType: 5,
        price: 2500,
    },
    {
        id: 6,
        imageType: 6,
        price: 5000,
    },
    {
        id: 7,
        imageType: 7,
        price: 7500,
    },
    {
        id: 8,
        imageType: 8,
        price: 10000,
    },
];


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-card\model\types.ts =====

// @/widgets/machine-card/model/types.ts
import { MachineWithState } from '@/entities/machine';

type CardAction = 'purchased' | 'activated' | 'transitioned';
export interface MachineCardProps {
    image: string;
    price: number;
    status: 'not_purchased' | 'awaiting' | 'in_progress' | 'waiting_for_reward' | 'completed';
    isPurchased: boolean;
    onAction?: (action: CardAction, machineId: number) => void;
    machineData?: MachineWithState;
}

export interface MachineInfoModalProps {
    isOpen: boolean;
    onClose: () => void;
    machine: MachineWithState;
    status: string;
}


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-card\ui\MachineCard.tsx =====

'use client';

// @/widgets/machine-card/ui/MachineCard.tsx
import { useCallback, useEffect, useState } from 'react';
import { memo } from 'react';
import Image from 'next/image';
import clsx from 'clsx';
import { activateMachine, purchaseMachine, transitionMachine } from '@/entities/machine';
import { useUser } from '@/entities/user';
import { ClaimAnimation } from '@/features/claim-animation';
import { Coin } from '@/shared/assets/icons';
import { useMachines } from '@/shared/lib/contexts/MachineContext';
import { useTimers } from '@/shared/lib/contexts/TimerContext';
import { InfoButton, ProgressBar } from '@/shared/ui';
import { MachineCardProps } from '../model';
import styles from './MachineCard.module.scss';
import { MachineInfoModal } from './MachineInfoModal';

export const MachineCard = memo(
    ({ status, price, image, machineData, onAction }: MachineCardProps) => {
        const { updateMachineStatusLocally, updateMachineRemainingUses } = useMachines();
        const { timers, startTimer, stopTimer, getTimer, isTimerActive } = useTimers();
        const { refreshUserBalance } = useUser();
        const [isModalOpen, setIsModalOpen] = useState(false);
        const [currentStatus, setCurrentStatus] = useState(status);
        const [lastUpdated, setLastUpdated] = useState<number | null>(null);
        const [isProcessing, setIsProcessing] = useState(false);
        const [actionError, setActionError] = useState<string | null>(null);
        const [isCollectingReward, setIsCollectingReward] = useState(false);
        const [showClaimAnimation, setShowClaimAnimation] = useState(false);

        const isPurchased = currentStatus !== 'not_purchased';

        const totalActivations = machineData?.car?.lifespan ?? 0;
        const [remainingUses, setRemainingUses] = useState<number>(
            machineData?.state_car?.remaining_uses ?? 0
        );

        // Получаем данные таймера для этой машины
        const timerData = getTimer(machineData?.car?.id || 0);

        // Синхронизируем локальный статус и remainingUses с пропсами при их изменении
        useEffect(() => {
            setCurrentStatus(status);
            setRemainingUses(machineData?.state_car?.remaining_uses ?? 0);
        }, [status, machineData?.state_car?.remaining_uses]);

        // --- Рассчитываем доход за активацию ---
        const earnings = Number(machineData?.car?.daily_replenishment || 0);

        // --- Получаем время работы (мемоизировано) ---
        const getWorkTime = useCallback((): number => {
            const workTime = Number(process.env.NEXT_PUBLIC_CAR_WORK_TIME);
            return isNaN(workTime) ? 30 : workTime;
        }, []);

        // --- Обновляем lastUpdated при изменении machineData ---
        useEffect(() => {
            if (machineData?.state_car?.last_updated) {
                setLastUpdated(machineData.state_car.last_updated);
            }
        }, [machineData?.state_car?.last_updated]);

        // --- Управление таймером ---
        useEffect(() => {
            const machineId = machineData?.car?.id;
            if (!machineId || !lastUpdated) return;

            if (currentStatus === 'in_progress') {
                // Запускаем таймер только если он еще не активен
                if (!isTimerActive(machineId)) {
                    startTimer(machineId, lastUpdated, getWorkTime());
                }
            } else {
                // Останавливаем таймер для других статусов
                if (currentStatus !== 'waiting_for_reward') {
                    stopTimer(machineId);
                }
            }

            return () => {
                // Не останавливаем таймер при размонтировании для статуса in_progress
                if (currentStatus !== 'in_progress') {
                    stopTimer(machineId);
                }
            };
        }, [
            currentStatus,
            lastUpdated,
            machineData?.car?.id,
            startTimer,
            stopTimer,
            getWorkTime,
            isTimerActive,
        ]);

        // --- Обработчики событий ---
        const handleMachinePurchased = useCallback(
            (event: CustomEvent) => {
                if (event.detail.machineId === machineData?.car?.id) {
                    setCurrentStatus('awaiting');
                }
            },
            [machineData?.car?.id]
        );

        const handleMachineActivated = useCallback(
            (event: CustomEvent) => {
                if (event.detail.machineId === machineData?.car?.id) {
                    setCurrentStatus('in_progress');
                    setLastUpdated(event.detail.lastUpdated || Math.floor(Date.now() / 1000));
                }
            },
            [machineData?.car?.id]
        );

        useEffect(() => {
            window.addEventListener('machinePurchased', handleMachinePurchased as EventListener);
            window.addEventListener('machineActivated', handleMachineActivated as EventListener);

            return () => {
                window.removeEventListener(
                    'machinePurchased',
                    handleMachinePurchased as EventListener
                );
                window.removeEventListener(
                    'machineActivated',
                    handleMachineActivated as EventListener
                );
            };
        }, [handleMachinePurchased, handleMachineActivated]);

        // --- Обработчик покупки ---
        const handleBuy = async () => {
            if (isProcessing || !machineData?.car?.id) return;

            setIsProcessing(true);
            setActionError(null);

            try {
                const success = await purchaseMachine({ car_id: machineData.car.id });

                if (success) {
                    console.log(`Машина ${machineData.car.id} успешно куплена.`);

                    setCurrentStatus('awaiting');
                    updateMachineStatusLocally(machineData.car.id, 'awaiting');

                    window.dispatchEvent(
                        new CustomEvent('machinePurchased', {
                            detail: { machineId: machineData.car.id },
                        })
                    );

                    if (onAction) {
                        onAction('purchased', machineData.car.id);
                    }

                    try {
                        await refreshUserBalance();
                        console.log('Баланс пользователя обновлён после покупки машины.');
                    } catch (balanceError) {
                        console.error(
                            'Ошибка обновления баланса после покупки машины:',
                            balanceError
                        );
                    }
                } else {
                    throw new Error('Сервер сообщил о неудаче операции.');
                }
            } catch (err) {
                console.error('Ошибка при покупке машины:', err);
                let errorMessage = 'Произошла ошибка при покупке. Пожалуйста, попробуйте позже.';
                if (err instanceof Error) {
                    if (err.message.includes('Insufficient funds')) {
                        errorMessage = 'Недостаточно средств на балансе.';
                    }
                }
                setActionError(errorMessage);
            } finally {
                setIsProcessing(false);
            }
        };

        // --- Обработчик активации ---
        const handleActivate = async () => {
            if (currentStatus !== 'awaiting') {
                console.warn('Попытка активации в неправильном статусе:', currentStatus);
                setIsProcessing(false);
                return;
            }

            if (isProcessing || !machineData?.car?.id) return;

            setIsProcessing(true);
            setActionError(null);

            try {
                const result = await activateMachine({ car_id: machineData.car.id });

                if (result) {
                    console.log(`Машина ${machineData.car.id} активирована.`);

                    const newRemainingUses = Math.max(0, remainingUses - 1);
                    updateMachineRemainingUses(machineData.car.id, newRemainingUses);
                    setRemainingUses(newRemainingUses);

                    const newStatus = 'in_progress';
                    setCurrentStatus(newStatus);
                    updateMachineStatusLocally(machineData.car.id, newStatus);

                    const lastUpdated = Math.floor(Date.now() / 1000);
                    setLastUpdated(lastUpdated);

                    if (onAction) {
                        onAction('activated', machineData.car.id);
                    }
                }
            } catch (err) {
                console.error('Ошибка активации:', err);
                setActionError('Ошибка активации машины');
            } finally {
                setIsProcessing(false);
            }
        };

        // --- Обработчик получения награды ---
        const handleCollectReward = async () => {
            if (currentStatus !== 'waiting_for_reward') {
                console.warn('Попытка получить награду в неправильном статусе:', currentStatus);
                setIsProcessing(false);
                return;
            }

            if (isProcessing || !machineData?.state_car?.id) return;

            setIsProcessing(true);
            setActionError(null);
            setIsCollectingReward(true);
            setShowClaimAnimation(true);

            try {
                const result = await transitionMachine({
                    car_to_user_id: machineData.state_car.id,
                });

                if (result) {
                    console.log(`Награда получена для машины ${machineData.car.id}.`);

                    const nextState = remainingUses > 0 ? 'awaiting' : 'completed';
                    setCurrentStatus(nextState);
                    updateMachineStatusLocally(machineData.car.id, nextState);

                    try {
                        await refreshUserBalance();
                        console.log('Баланс пользователя обновлён после получения награды.');
                    } catch (balanceError) {
                        console.error('Ошибка обновления баланса:', balanceError);
                    }
                }
            } catch (err) {
                console.error('Ошибка получения награды:', err);
                setActionError('Ошибка получения награды');
            } finally {
                setTimeout(() => {
                    setShowClaimAnimation(false);
                    setIsCollectingReward(false);
                }, 1000);
                setIsProcessing(false);
            }
        };

        // --- Получить текст для отображения вместо цены ---
        const getDisplayText = useCallback(() => {
            if (!isPurchased) {
                return `${price} USDT`;
            }

            switch (currentStatus) {
                case 'awaiting':
                    return (
                        <>
                            +{earnings} <Coin width={20} height={20} />
                        </>
                    );
                case 'in_progress':
                    // Используем данные из контекста таймеров
                    return (
                        <span className={styles.timer}>
                            {timerData?.timeLeftFormatted || '24:00:00'}
                        </span>
                    );
                case 'waiting_for_reward':
                    return (
                        <>
                            {earnings} <Coin width={20} height={20} />
                        </>
                    );
                case 'completed':
                    return 'Завершена';
                default:
                    return `${price} USDT`;
            }
        }, [isPurchased, currentStatus, price, earnings, timerData?.timeLeftFormatted]);

        // --- Получить текст для статуса ---
        const getStatusText = useCallback(() => {
            if (!isPurchased) return 'Купить';

            switch (currentStatus) {
                case 'awaiting':
                    return 'Активировать';
                case 'in_progress':
                    // Используем прогресс из контекста таймеров
                    return <ProgressBar progress={timerData?.progress || 0} />;
                case 'waiting_for_reward':
                    return 'Забрать';
                case 'completed':
                    return 'Купить';
                default:
                    return 'Куплена';
            }
        }, [isPurchased, currentStatus, timerData?.progress]);

        // --- Получить обработчик для события ---
        const getActionHandler = () => {
            if (!machineData?.car?.id) return undefined;

            if (!isPurchased) {
                return handleBuy;
            }

            switch (currentStatus) {
                case 'awaiting':
                    return handleActivate;
                case 'waiting_for_reward':
                    return handleCollectReward;
                default:
                    return undefined;
            }
        };

        const actionHandler = getActionHandler();

        return (
            <>
                <div className={styles.cardWrapper}>
                    <button
                        className={clsx(styles.card)}
                        onClick={actionHandler}
                        type="button"
                        aria-label={`${machineData!.car.name}`}
                        disabled={isProcessing}
                    >
                        <div className={styles.info}>
                            {isPurchased ? (
                                <span
                                    className={styles.activationsDisplay}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        setIsModalOpen(true);
                                    }}
                                >
                                    {remainingUses} / {totalActivations}
                                </span>
                            ) : (
                                <InfoButton
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        setIsModalOpen(true);
                                    }}
                                />
                            )}
                        </div>

                        <div className={clsx(styles.plate, styles[`${currentStatus}`])} />

                        <Image
                            className={clsx(styles.image, { [styles.purchased]: isPurchased })}
                            src={`/images/${image}`}
                            width={100}
                            height={100}
                            alt="Майнинг-машина"
                        />

                        {getDisplayText() && (
                            <span className={styles.displayText}>{getDisplayText()}</span>
                        )}

                        {getStatusText() && (
                            <span className={styles.statusText}>{getStatusText()}</span>
                        )}

                        {actionError && <div className={styles.buyError}>{actionError}</div>}
                    </button>

                    {showClaimAnimation && <ClaimAnimation />}
                </div>

                {machineData && (
                    <MachineInfoModal
                        isOpen={isModalOpen}
                        onClose={() => setIsModalOpen(false)}
                        machine={machineData}
                        status={currentStatus}
                    />
                )}
            </>
        );
    }
);

MachineCard.displayName = 'MachineCard';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-card\ui\MachineInfoModal.tsx =====

// @/widgets/machine-card/ui/MachineInfoModal.tsx
import Image from 'next/image';
import { Coin } from '@/shared/assets/icons';
import { Modal } from '@/shared/ui';
import { MachineInfoModalProps } from '../model';
import styles from './MachineInfoModal.module.scss';

export const MachineInfoModal = ({ isOpen, onClose, machine }: MachineInfoModalProps) => {
    // --- Рассчитываем доход за активацию ---
    const earnings = Number(machine.car.daily_replenishment || 0);

    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <div className={styles.machineInfo}>
                <h2 className={styles.title}>{machine.car.name}</h2>

                <Image
                    src={`/images/${machine.car.image}`}
                    width={200}
                    height={200}
                    alt="Майнинг-машина"
                />

                <div className={styles.infoGrid}>
                    <div className={styles.infoItem}>
                        <p className={styles.label}>Цена:</p>
                        <p className={styles.value}>
                            {machine.car.price} <Coin width={20} height={20} />
                        </p>
                    </div>

                    <div className={styles.infoItem}>
                        <p className={styles.label}>Заряды:</p>
                        <p className={styles.value}>{machine.car.lifespan}</p>
                    </div>

                    <div className={styles.infoItem}>
                        <p className={styles.label}>Время работы 1 заряда:</p>
                        <p className={styles.value}>24 часа</p>
                    </div>

                    <div className={styles.infoItem}>
                        <p className={styles.label}>Доход за 1 заряд:</p>
                        <p className={styles.value}>
                            +{earnings} <Coin width={20} height={20} />
                        </p>
                    </div>
                </div>
            </div>
        </Modal>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-card\ui\index.ts =====

export { MachineCard } from './MachineCard';
export { MachineInfoModal } from './MachineInfoModal';
export {} from './';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-list\index.ts =====

// export * from './model';
export * from './ui';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-list\model\index.ts =====

export type { MachineListProps } from './types';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-list\model\types.ts =====

import { MachineWithState } from '@/entities/machine';

export interface MachineListProps {
    machines?: MachineWithState[];
    filterType: 'purchased' | 'not_purchased' | 'all';
    showBuyMoreCard: boolean;
}


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-list\ui\ClaimAnimation.tsx =====

// import { useEffect, useState } from 'react';
// import moleCoin from '@/assets/icons/mole-coin.webp';
// import tonCoin from '@/assets/icons/ton-coin.webp';
// import './ClaimAnimation.scss';

// const getRandomCoin = () => (Math.random() > 0.5 ? tonCoin : moleCoin);

// export const ClaimAnimation = () => {
//     const [shouldAnimateCoins, setShouldAnimateCoins] = useState(false);
//     const [coinType, setcoinType] = useState<string[]>([]);

//     useEffect(() => {
//         setcoinType([
//             getRandomCoin(),
//             getRandomCoin(),
//             getRandomCoin(),
//             getRandomCoin(),
//             getRandomCoin(),
//         ]);
//         setShouldAnimateCoins(true);
//     }, []);

//     return (
//         <div className="ClaimAnimation">
//             <img className={`Coin Coin_Central`} src={tonCoin} alt="coin" />
//             <img
//                 className={`Coin Coin_TopLeft ${shouldAnimateCoins ? 'animate' : ''}`}
//                 src={coinType[0]}
//                 alt="coin"
//             />
//             <img
//                 className={`Coin Coin_TopRight ${shouldAnimateCoins ? 'animate' : ''}`}
//                 src={coinType[1]}
//                 alt="coin"
//             />
//             <img
//                 className={`Coin Coin_BottomRight ${shouldAnimateCoins ? 'animate' : ''}`}
//                 src={coinType[2]}
//                 alt="coin"
//             />
//             <img
//                 className={`Coin Coin_BottomLeft ${shouldAnimateCoins ? 'animate' : ''}`}
//                 src={coinType[3]}
//                 alt="coin"
//             />
//         </div>
//     );
// };


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-list\ui\MachineList.tsx =====

'use client';

// @/features/mining/ui/MachineList.tsx
import React from 'react';
import Link from 'next/link';
import { useMachines } from '@/shared/lib/contexts/MachineContext';
import { MachineCard } from '@/widgets/machine-card';
import { MachineListProps } from '../model';
import styles from './MachineList.module.scss';

export const MachineList = ({
    machines: propMachines,
    filterType = 'all',
    showBuyMoreCard = false,
}: MachineListProps) => {
    // Используем контекст если machines не переданы
    const { machines: contextMachines } = useMachines();

    // Используем переданные машины или машины из контекста
    const machinesToUse = propMachines || contextMachines;

    // Фильтрация по типу
    const filteredMachines = machinesToUse.filter(({ state_car }) => {
        const status = state_car?.status ?? 'not_purchased';
        switch (filterType) {
            case 'purchased':
                return status !== 'not_purchased';
            case 'not_purchased':
                return status === 'not_purchased';
            case 'all':
            default:
                return true;
        }
    });

    // Сортировка от самой дешевой к самой дорогой
    const sortedMachines = [...filteredMachines].sort((a, b) => {
        return a.car.price - b.car.price;
    });

    const shouldShowBuyMore = showBuyMoreCard && filterType === 'purchased';

    return (
        <div className={styles.machineList}>
            {shouldShowBuyMore && (
                <Link href="/shop" className={styles.buyMoreCard}>
                    <div className={styles.plate} />
                    <span className={styles.add}>+</span>
                    <span className={styles.label}>Купить ещё</span>
                </Link>
            )}

            {sortedMachines.map((machineWithState) => {
                const { car, state_car } = machineWithState;
                const status = state_car?.status ?? 'not_purchased';
                const isPurchased = status !== 'not_purchased';

                return (
                    <MachineCard
                        key={car.id}
                        image={car.image}
                        price={car.price}
                        status={status}
                        isPurchased={isPurchased}
                        machineData={machineWithState}
                    />
                );
            })}
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\machine-list\ui\index.ts =====

export { MachineList } from './MachineList';
export {} from './';
export {} from './';
export {} from './';
export {} from './';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-balance\index.ts =====

export { ReferralBalance } from './ui/ReferralBalance';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-balance\ui\ReferralBalance.tsx =====

'use client';

// src/widgets/balance/ui/Balance.tsx
import CountUp from 'react-countup';
import { convertCurrency, useCurrencyConverter } from '@/features/currency-converter';
import { Coin } from '@/shared/assets/icons';
import { useUser } from '@/shared/lib/contexts/UserContext';
import styles from './ReferralBalance.module.scss';

export const ReferralBalance = () => {
    const { user } = useUser();
    const { rates } = useCurrencyConverter();

    const userBalance =
        user?.referrer_profit !== undefined && user?.referrer_profit !== null
            ? Number(user.referrer_profit)
            : 0;

    const balanceRub = rates
        ? convertCurrency({
              amount: userBalance,
              from: 'USDT',
              to: 'RUB',
              rates: rates,
          })
        : 0;

    const formattedBalanceRub = balanceRub.toFixed(2);
    const formattedBalanceUSDT = userBalance.toFixed(2);

    return (
        <div className={styles.balance}>
            <div className={styles.balanceRUB}>
                <CountUp
                    end={parseFloat(formattedBalanceRub)}
                    decimals={2}
                    duration={1}
                    separator=" "
                    decimal="."
                    prefix=""
                    suffix=" "
                />
                <span>₽</span>
            </div>
            <div className={styles.balanceUSDT}>
                <CountUp
                    end={parseFloat(formattedBalanceUSDT)} // Преобразуем в число
                    decimals={2}
                    duration={0.5} // Продолжительность анимации в секундах
                    separator=" " // Разделитель тысяч (если нужно)
                    decimal="."
                    prefix="" // Префикс (если нужен, например, "$")
                    suffix=" "
                    className={styles.value}
                />
                <Coin width={40} height={40} />
            </div>
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-card\index.ts =====

export { ReferralCard } from './ui/ReferralCard';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-card\model\index.ts =====

export type { MachineCardProps } from './types';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-card\model\machines.ts =====

// @/widgets/machine-card/model/machines.ts
export const MACHINES = [
    {
        id: 1,
        imageType: 1,
        price: 15,
    },
    {
        id: 2,
        imageType: 3,
        price: 150,
    },
    {
        id: 3,
        imageType: 3,
        price: 500,
    },
    {
        id: 4,
        imageType: 4,
        price: 1000,
    },
    {
        id: 5,
        imageType: 5,
        price: 2500,
    },
    {
        id: 6,
        imageType: 6,
        price: 5000,
    },
    {
        id: 7,
        imageType: 7,
        price: 7500,
    },
    {
        id: 8,
        imageType: 8,
        price: 10000,
    },
];


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-card\model\types.ts =====

export type MachineCardProps = {
    className?: string;
    plateType: number;
    imageType: number;
    price: number;
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-card\ui\ReferralCard.tsx =====

// @/widgets/referral-card/ui/ReferralCard.tsx
import Image from 'next/image';
import { UserAttributes } from '@/entities/user/model/types';
import { Coin } from '@/shared/assets/icons';
import styles from './ReferralCard.module.scss';

// Пропсы для карточки реферала
interface ReferralCardProps {
    referral: Omit<UserAttributes, 'ban_until' | 'created_at' | 'updated_at'>;
}

export const ReferralCard = ({ referral }: ReferralCardProps) => {
    // Получаем значение ref_balance, которое может быть number, string, null или undefined
    const refBalanceValue = referral.ref_balance;

    // Преобразуем значение в число
    let numericProfit: number;
    if (typeof refBalanceValue === 'number') {
        numericProfit = refBalanceValue;
    } else if (typeof refBalanceValue === 'string') {
        // Пробуем преобразовать строку в число
        numericProfit = parseFloat(refBalanceValue);
        // Если parseFloat вернул NaN, заменяем на 0
        if (isNaN(numericProfit)) {
            numericProfit = 0;
        }
    } else {
        // Если null, undefined или другой тип, используем 0
        numericProfit = 0;
    }

    // Форматируем число до 2 знаков после запятой
    const profit = numericProfit.toFixed(2);

    return (
        <div className={styles.card}>
            <Image
                className={styles.avatar}
                src={`/images/mascot.webp`}
                width={100}
                height={100}
                alt={`Аватар ${referral.username}`}
            />
            <span className={styles.username}>{referral.username}</span>
            <span className={styles.profit}>
                +{profit} <Coin width={20} height={20} />
            </span>
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-link\ReferralLink.tsx =====

// @/shared/ui/referral-link/ReferralLink.tsx
import { Copy } from '@/shared/assets/icons';
import { Input } from '@/shared/ui';
import styles from './ReferralLink.module.scss';

interface ReferralLinkProps {
    telegramId?: number;
}

export const ReferralLink = ({ telegramId }: ReferralLinkProps) => {
    const referralLink = `https://t.me/RoboMine_CapitalBot?start=${telegramId}`;

    const handleCopy = async () => {
        navigator.clipboard.writeText(referralLink).then(() => {});
    };

    return (
        <div className={styles.referralLinkWrapper}>
            <button
                className={styles.referralLink}
                onClick={handleCopy}
                type="button"
                aria-label={''}
            >
                <Input
                    className={styles.input}
                    type="text"
                    variant="default"
                    placeholder="Реферальная ссылка"
                    value={referralLink}
                    readOnly
                />

                <Copy className={styles.copyIcon} />
            </button>
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-link\index.ts =====

export { ReferralLink } from './ReferralLink';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-list\index.ts =====

export { ReferralList } from './ui/ReferralList';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\referral-list\ui\ReferralList.tsx =====

'use client';

// @/features/referral/ui/ReferralList.tsx
import { UserAttributes } from '@/entities/user';
import { ReferralCard } from '@/widgets/referral-card';
import styles from './ReferralList.module.scss';

interface ReferralListProps {
    referrals: Omit<UserAttributes, 'ban_until' | 'created_at' | 'updated_at'>[];
}

export const ReferralList = ({ referrals }: ReferralListProps) => {
    if (referrals.length === 0) {
        return <p className={styles.emptyList}>У вас пока нет рефералов.</p>;
    }

    return (
        <div className={styles.referralList}>
            {referrals.map((referral) => (
                <ReferralCard key={referral.telegram_id} referral={referral} />
            ))}
        </div>
    );
};


===== C:\Users\USER\Projects\robomine-capital\src\widgets\user\index.ts =====

export { User } from './ui/User';


===== C:\Users\USER\Projects\robomine-capital\src\widgets\user\ui\User.tsx =====

'use client';

import { useUser } from '@/entities/user';
import styles from './User.module.scss';

export const User = () => {
    const { user } = useUser();

    return (
        <div className={styles.user}>
            {/* <span className={styles.userStatus}>{String(user?.blago_status)}</span> */}
            <span className={styles.userName}>
                {user?.username || `Пользователь ${user?.telegram_id}`}
            </span>
        </div>
    );
};


===== СТРУКТУРА ПРОЕКТА =====

.
├── .env.local
├── .eslintrc.js
├── .prettierrc
├── collect-code.js
├── eslint.config.mjs
├── full_code.txt
├── next-env.d.ts
├── next.config.ts
├── package-lock.json
├── package.json
├── public
    ├── icons
    └── images
    │   ├── machine0.png
    │   ├── machine0.webp
    │   ├── machine1.png
    │   ├── machine1.webp
    │   ├── machine2.png
    │   ├── machine2.webp
    │   ├── machine3.png
    │   ├── machine3.webp
    │   ├── machine4.png
    │   ├── machine4.webp
    │   ├── machine5.png
    │   ├── machine5.webp
    │   ├── machine6.png
    │   ├── machine6.webp
    │   ├── machine7.png
    │   ├── machine7.webp
    │   ├── machine8.png
    │   ├── machine8.webp
    │   ├── mascot.png
    │   ├── mascot.webp
    │   ├── splash-screen.jpg
    │   ├── splash-screen.webp
    │   └── splash-screen.wp2
├── README.md
├── src
    ├── app
    │   ├── deposit
    │   │   ├── Deposit.module.scss
    │   │   └── page.tsx
    │   ├── error.tsx
    │   ├── Home.module.scss
    │   ├── icon.svg
    │   ├── layout.module.scss
    │   ├── layout.tsx
    │   ├── loading.tsx
    │   ├── not-found.tsx
    │   ├── page.tsx
    │   ├── referral
    │   │   ├── page.tsx
    │   │   └── Referral.module.scss
    │   ├── shop
    │   │   ├── page.tsx
    │   │   └── Shop.module.scss
    │   └── withdraw
    │   │   ├── page.tsx
    │   │   └── Withdraw.module.scss
    ├── entities
    │   ├── deposit
    │   │   ├── api
    │   │   │   ├── deposit.api.ts
    │   │   │   └── index.ts
    │   │   ├── index.ts
    │   │   ├── model
    │   │   │   ├── index.ts
    │   │   │   └── types.ts
    │   │   └── ui
    │   │   │   └── index.ts
    │   ├── machine
    │   │   ├── api
    │   │   │   ├── index.ts
    │   │   │   └── machine.api.ts
    │   │   ├── index.ts
    │   │   ├── lib
    │   │   │   └── status.ts
    │   │   ├── model
    │   │   │   ├── index.ts
    │   │   │   └── types.ts
    │   │   └── ui
    │   │   │   └── index.ts
    │   ├── user
    │   │   ├── api
    │   │   │   ├── index.ts
    │   │   │   └── user.api.ts
    │   │   ├── index.ts
    │   │   ├── model
    │   │   │   ├── index.ts
    │   │   │   ├── types.ts
    │   │   │   └── useUserInit.ts
    │   │   └── ui
    │   │   │   └── index.ts
    │   └── withdrawal
    │   │   ├── api
    │   │       ├── index.ts
    │   │       └── withdrawal.api.ts
    │   │   ├── index.ts
    │   │   ├── model
    │   │       ├── index.ts
    │   │       └── types.ts
    │   │   └── ui
    │   │       └── index.ts
    ├── features
    │   ├── auth
    │   ├── claim-animation
    │   │   ├── index.ts
    │   │   └── ui
    │   │   │   ├── ClaimAnimation.module.scss
    │   │   │   ├── ClaimAnimation.tsx
    │   │   │   └── index.ts
    │   ├── currency-converter
    │   │   ├── index.ts
    │   │   ├── model
    │   │   │   ├── converter.ts
    │   │   │   ├── index.ts
    │   │   │   ├── types.ts
    │   │   │   └── useCurrencyConverter.tsx
    │   │   └── ui
    │   ├── deposit
    │   │   ├── index.ts
    │   │   ├── model
    │   │   │   └── types.ts
    │   │   └── ui
    │   │   │   ├── DepositForm.module.scss
    │   │   │   └── DepositForm.tsx
    │   ├── purchase-machine
    │   │   ├── model
    │   │   └── ui
    │   ├── timer
    │   │   ├── model
    │   │   │   └── useTimer.ts
    │   │   └── ui
    │   └── withdraw
    │   │   ├── index.ts
    │   │   ├── model
    │   │       ├── hooks.ts
    │   │       └── types.ts
    │   │   └── ui
    │   │       ├── WithdrawForm.module.scss
    │   │       └── WithdrawForm.tsx
    ├── shared
    │   ├── api
    │   │   ├── axios.ts
    │   │   ├── index.ts
    │   │   └── telegram-web-app.d.ts
    │   ├── assets
    │   │   └── icons
    │   │   │   ├── Arrow.tsx
    │   │   │   ├── Coin.tsx
    │   │   │   ├── Copy.tsx
    │   │   │   ├── index.ts
    │   │   │   ├── Info.tsx
    │   │   │   └── Invite.tsx
    │   ├── config
    │   │   ├── env.ts
    │   │   └── index.ts
    │   ├── lib
    │   │   ├── contexts
    │   │   │   ├── index.ts
    │   │   │   ├── MachineContext.tsx
    │   │   │   ├── ReferralContext.tsx
    │   │   │   ├── TimerContext.tsx
    │   │   │   └── UserContext.tsx
    │   │   ├── hooks
    │   │   │   └── useTelegramWebApp.ts
    │   │   ├── index.ts
    │   │   └── providers
    │   │   │   ├── AppProviders.tsx
    │   │   │   └── index.ts
    │   ├── styles
    │   │   ├── global.scss
    │   │   ├── _animations.scss
    │   │   ├── _mixins.scss
    │   │   └── _variables.scss
    │   └── ui
    │   │   ├── back-button
    │   │       ├── BackButton.module.scss
    │   │       ├── BackButton.tsx
    │   │       └── index.ts
    │   │   ├── button
    │   │       ├── Button.module.scss
    │   │       ├── Button.tsx
    │   │       ├── index.ts
    │   │       └── types.ts
    │   │   ├── index.ts
    │   │   ├── info-button
    │   │       ├── index.ts
    │   │       ├── InfoButton.module.scss
    │   │       ├── InfoButton.tsx
    │   │       └── types.ts
    │   │   ├── input
    │   │       ├── index.ts
    │   │       ├── Input.module.scss
    │   │       ├── Input.tsx
    │   │       └── types.ts
    │   │   ├── maintenance-screen
    │   │       ├── MaintenanceScreen.module.scss
    │   │       └── MaintenanceScreen.tsx
    │   │   ├── modal
    │   │       ├── index.ts
    │   │       ├── Modal.module.scss
    │   │       └── Modal.tsx
    │   │   ├── progres-bar
    │   │       ├── index.ts
    │   │       ├── ProgressBar.module.scss
    │   │       └── ProgressBar.tsx
    │   │   └── splash-screen
    │   │       ├── index.ts
    │   │       ├── SplashScreen.module.scss
    │   │       └── SplashScreen.tsx
    └── widgets
    │   ├── action-buttons
    │       ├── index.ts
    │       ├── model
    │       └── ui
    │       │   ├── ActionButtons.module.scss
    │       │   └── ActionButtons.tsx
    │   ├── balance
    │       ├── index.ts
    │       ├── model
    │       └── ui
    │       │   ├── Balance.module.scss
    │       │   └── Balance.tsx
    │   ├── by-machine-link
    │       ├── BuyMachineLink.module.scss
    │       ├── BuyMachineLink.tsx
    │       └── index.ts
    │   ├── header
    │       ├── index.ts
    │       ├── model
    │       │   └── store
    │       └── ui
    │       │   ├── Header.module.scss
    │       │   └── Header.tsx
    │   ├── machine-card
    │       ├── index.ts
    │       ├── model
    │       │   ├── index.ts
    │       │   ├── machines.ts
    │       │   └── types.ts
    │       └── ui
    │       │   ├── index.ts
    │       │   ├── MachineCard.module.scss
    │       │   ├── MachineCard.tsx
    │       │   ├── MachineInfoModal.module.scss
    │       │   └── MachineInfoModal.tsx
    │   ├── machine-list
    │       ├── index.ts
    │       ├── model
    │       │   ├── index.ts
    │       │   └── types.ts
    │       └── ui
    │       │   ├── ClaimAnimation.tsx
    │       │   ├── index.ts
    │       │   ├── MachineList.module.scss
    │       │   └── MachineList.tsx
    │   ├── referral
    │       ├── model
    │       └── ui
    │   ├── referral-balance
    │       ├── index.ts
    │       ├── model
    │       └── ui
    │       │   ├── ReferralBalance.module.scss
    │       │   └── ReferralBalance.tsx
    │   ├── referral-card
    │       ├── index.ts
    │       ├── model
    │       │   ├── index.ts
    │       │   ├── machines.ts
    │       │   └── types.ts
    │       └── ui
    │       │   ├── ReferralCard.module.scss
    │       │   └── ReferralCard.tsx
    │   ├── referral-link
    │       ├── index.ts
    │       ├── ReferralLink.module.scss
    │       └── ReferralLink.tsx
    │   ├── referral-list
    │       ├── index.ts
    │       └── ui
    │       │   ├── ReferralList.module.scss
    │       │   └── ReferralList.tsx
    │   └── user
    │       ├── index.ts
    │       ├── model
    │       └── ui
    │           ├── User.module.scss
    │           └── User.tsx
└── tsconfig.json
